@startuml
hide circle
skinparam classAttributeIconSize 0
class ProductosApplication {
  public static void main(String[] args) {
  public void init() {
  TimeZone.setDefault(TimeZone.getTimeZone("America/Argentina/Buenos_Aires"));
  System.out.println("✅ Zona horaria configurada a: " + TimeZone.getDefault().getID());
}
class ChatbotController {
  private ChatbotService chatbotService
  String twiMLResponse = chatbotService.procesarMensajeWebhook(from, body);
  return ResponseEntity.ok(twiMLResponse);
  } catch (Exception e) {
  String twiMLError = chatbotService.procesarMensajeWebhook(from, "error_interno");
  return ResponseEntity.ok(twiMLError);
}
class VentaController {
  private VentaService ventaService
  private PdfService pdfService
  public ResponseEntity<VentaDTO> crearVenta(@Valid @RequestBody VentaDTO ventaDTO, Principal principal) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String vendedorEmail = principal.getName();
  VentaDTO ventaCreada = ventaService.create(ventaDTO, vendedorEmail);
  return new ResponseEntity<>(ventaCreada, HttpStatus.CREATED);
  public ResponseEntity<byte[]> descargarComprobante(@PathVariable Long id, Authentication authentication) {
  Venta ventaCompleta = ventaService.findVentaByIdWithDetails(id);
  if (authentication != null && authentication.getAuthorities().stream().anyMatch(a -> a.getAuthority().equals("ROLE_CLIENTE"))) {
  String emailUsuario = authentication.getName();
  if (!ventaCompleta.getCliente().getEmail().equals(emailUsuario)) {
  return new ResponseEntity<>(HttpStatus.FORBIDDEN);
  byte[] pdfBytes = pdfService.generarComprobanteVenta(ventaCompleta);
  HttpHeaders headers = new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_PDF);
  headers.setContentDispositionFormData("attachment", "Comprobante-Venta-" + id + ".pdf");
  headers.setContentLength(pdfBytes.length);
  return new ResponseEntity<>(pdfBytes, headers, HttpStatus.OK);
  public ResponseEntity<?> getVentaById(@PathVariable Long id, Authentication authentication) {
  Venta ventaEntity = ventaService.findVentaByIdWithDetails(id);
  boolean esCliente = authentication.getAuthorities().stream()
  .anyMatch(a -> a.getAuthority().equals("ROLE_CLIENTE"));
  if (esCliente) {
  String emailUsuario = authentication.getName();
  if (!ventaEntity.getCliente().getEmail().equals(emailUsuario)) {
  return ResponseEntity.status(HttpStatus.FORBIDDEN)
  .body("No tienes permiso para ver esta venta.");
  VentaDTO ventaDTO = ventaService.findById(id);
  return ResponseEntity.ok(ventaDTO);
  } catch (Exception e) {
  logger.error("Error al obtener venta: ", e);
  return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
  .body("Error al cargar la venta.");
  Page<VentaDTO> ventas = ventaService.findAll(pageable);
  return ResponseEntity.ok(ventas);
  boolean isVendedor = authentication.getAuthorities().stream()
  .anyMatch(ga -> ga.getAuthority().equals("ROLE_VENDEDOR"));
  boolean isAdmin = authentication.getAuthorities().stream()
  .anyMatch(ga -> ga.getAuthority().equals("ROLE_ADMIN"));
  if (!isAdmin && isVendedor) {
  String vendedorEmail = authentication.getName();
  logger.info("Filtrando ventas solo para el VENDEDOR: {}", vendedorEmail);
  Page<VentaDTO> ventasFiltradas = ventaService.findByCriteriaForVendedor(filtro, pageable, vendedorEmail);
  return ResponseEntity.ok(ventasFiltradas);
  } else if (isAdmin) {
  logger.info("Filtrando ventas como ADMIN.");
  Page<VentaDTO> ventasFiltradas = ventaService.findByCriteria(filtro, pageable);
  return ResponseEntity.ok(ventasFiltradas);
  return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
  public ResponseEntity<Void> cancelarVenta(@PathVariable Long id, Principal principal) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String usuarioEmailCancela = principal.getName();
  ventaService.cancelarVenta(id, usuarioEmailCancela);
  return ResponseEntity.noContent().build();
}
class RecompensaController {
  private RecompensaService recompensaService
  public ResponseEntity<List<RecompensaDTO>> obtenerDisponibles() {
  return ResponseEntity.ok(recompensaService.findDisponibles());
  public ResponseEntity<List<RecompensaDTO>> listarTodas() {
  return ResponseEntity.ok(recompensaService.findAll());
  public ResponseEntity<RecompensaDTO> obtenerPorId(@PathVariable Long id) {
  return ResponseEntity.ok(recompensaService.findById(id));
  public ResponseEntity<RecompensaDTO> crearRecompensa(@Valid @RequestBody RecompensaDTO dto) {
  RecompensaDTO creada = recompensaService.crear(dto);
  return new ResponseEntity<>(creada, HttpStatus.CREATED);
  public ResponseEntity<RecompensaDTO> actualizarRecompensa(@PathVariable Long id, @Valid @RequestBody RecompensaDTO dto) {
  RecompensaDTO actualizada = recompensaService.actualizar(id, dto);
  return ResponseEntity.ok(actualizada);
  public ResponseEntity<Void> eliminarRecompensa(@PathVariable Long id) {
  recompensaService.eliminar(id);
  return ResponseEntity.noContent().build();
}
class TipoDocumentoController {
  private TipoDocumentoRepository tipoDocumentoRepository
  public ResponseEntity<List<TipoDocumento>> getAllTiposDocumento() {
  return ResponseEntity.ok(tipoDocumentoRepository.findAll());
}
class ClienteController {
  private ClienteService clienteService
  private VentaService ventaService
  private CuponService cuponService
  public ResponseEntity<ClientePerfilDTO> getMiPerfil(Principal principal) {
  String userEmail = principal.getName();
  ClientePerfilDTO perfil = clienteService.getPerfilByEmail(userEmail);
  return ResponseEntity.ok(perfil);
  String userEmail = principal.getName();
  ClientePerfilDTO perfilActualizado = clienteService.updatePerfilByEmail(userEmail, updateDTO);
  return ResponseEntity.ok(perfilActualizado);
  String userEmail = principal.getName();
  clienteService.cambiarPassword(userEmail, dto);
  return ResponseEntity.noContent().build();
  String userEmail = principal.getName();
  Page<VentaResumenDTO> historial = ventaService.findVentasByClienteEmail(userEmail, pageable);
  return ResponseEntity.ok(historial);
  public ResponseEntity<Usuario> registrarDesdePos(@RequestBody ClienteDTO dto) {
  Usuario nuevoUsuario = clienteService.registrarClienteDesdePos(dto);
  return ResponseEntity.ok(nuevoUsuario);
  public ResponseEntity<List<CuponDTO>> getMisCupones(Principal principal) {
  String userEmail = principal.getName();
  List<CuponDTO> misCupones = cuponService.obtenerCuponesPorUsuario(userEmail);
  return ResponseEntity.ok(misCupones);
}
class ListaEsperaController {
  private ListaEsperaRepository listaEsperaRepository
  private ProductoRepository productoRepository
  private UsuarioRepository usuarioRepository
  )
  )
  public ResponseEntity<?> unirseALista(@RequestBody AddListaEsperaDTO dto) {
  logger.info("-> Solicitud de lista de espera: Usuario ID {} para Producto ID {}", dto.getUsuarioId(), dto.getProductoId());
  Usuario usuario = usuarioRepository.findById(dto.getUsuarioId())
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
  Producto producto = productoRepository.findById(dto.getProductoId())
  .orElseThrow(() -> new RuntimeException("Producto no encontrado"));
  if (producto.getStockActual() > 0) {
  return ResponseEntity.status(HttpStatus.BAD_REQUEST)
  .body(Map.of("mensaje", "¡Buena noticia! Este producto ya tiene stock, puedes comprarlo ahora."));
  if (yaEstaEnEspera) {
  return ResponseEntity.status(HttpStatus.CONFLICT)
  .body(Map.of("mensaje", "Ya estás anotado en la lista de espera para este producto."));
  ListaEspera nuevaEspera = new ListaEspera();
  nuevaEspera.setUsuario(usuario);
  nuevaEspera.setProducto(producto);
  nuevaEspera.setFechaInscripcion(LocalDate.now());
  nuevaEspera.setEstado(EstadoListaEspera.PENDIENTE);
  listaEsperaRepository.save(nuevaEspera);
  logger.info("-> ✅ Usuario {} agregado a lista de espera para '{}'", usuario.getEmail(), producto.getNombre());
  return ResponseEntity.ok(Map.of("mensaje", "¡Listo! Te avisaremos por correo cuando haya stock."));
  } catch (RuntimeException e) {
  logger.error("Error al unir a lista de espera: {}", e.getMessage());
  return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
  } catch (Exception e) {
  logger.error("Error inesperado en lista de espera", e);
  return ResponseEntity.internalServerError().body(Map.of("error", "Ocurrió un error al procesar tu solicitud."));
  public ResponseEntity<?> verificarEstado(@RequestParam Long usuarioId, @RequestParam Long productoId) {
  return ResponseEntity.ok(Map.of("estaEnEspera", estaPendiente));
}
class ProductoController {
  private ProductoService productoService
  private MovimientoStockService movimientoStockService
  private UsuarioRepository usuarioRepository
  String nuevoCodigo = productoService.generarCodigoAutomatico(categoriaId, nombre);
  return ResponseEntity.ok(Map.of("codigo", nuevoCodigo));
  Page<ProductoDTO> productos = productoService.findAll(pageable);
  return ResponseEntity.ok(productos);
  Page<ProductoDTO> productoPage = productoService.filter(filtro, pageable);
  return ResponseEntity.ok(productoPage);
  public ResponseEntity<ProductoDTO> getProductoById(@PathVariable Long id) {
  ProductoDTO producto = productoService.findById(id);
  return ResponseEntity.ok(producto);
  public ResponseEntity<ProductoDTO> createProducto(@Valid @RequestBody ProductoDTO productoDTO) {
  ProductoDTO nuevoProducto = productoService.create(productoDTO);
  return new ResponseEntity<>(nuevoProducto, HttpStatus.CREATED);
  public ResponseEntity<ProductoDTO> updateProducto(@PathVariable Long id, @Valid @RequestBody ProductoDTO productoDTO) {
  ProductoDTO productoActualizado = productoService.update(id, productoDTO);
  return ResponseEntity.ok(productoActualizado);
  public ResponseEntity<Map<String, String>> deleteProducto(@PathVariable Long id) {
  productoService.softDelete(id);
  return ResponseEntity.ok(Map.of("message", "Producto marcado como inactivo exitosamente"));
  public ResponseEntity<List<ProductoDTO>> getProductosByProveedor(@PathVariable Long proveedorId) {
  return ResponseEntity.ok(productoService.findByProveedorId(proveedorId));
  Page<ProductoDTO> pagina = productoService.searchByProveedor(proveedorId, search, pageable);
  return ResponseEntity.ok(pagina);
  public ResponseEntity<Void> realizarAjusteStock(@RequestBody @Valid MovimientoStockDTO dto, Principal principal) {
  System.out.println(">>> [CONTROLLER] Recibida petición de Ajuste Stock");
  Usuario usuarioLogueado = usuarioRepository.findByEmail(principal.getName())
  .orElseThrow(() -> new RuntimeException("Usuario autenticado no encontrado en BD"));
  dto.setUsuarioId(usuarioLogueado.getId());
  dto.setTipoMovimiento(com.masterserv.productos.enums.TipoMovimiento.AJUSTE_MANUAL);
  productoService.ajustarStock(dto, principal.getName());
  return ResponseEntity.ok().build();
}
class PuntosController {
  private PuntosService puntosService
  private com.masterserv.productos.service.UsuarioService usuarioService
  )
  public ResponseEntity<SaldoPuntosDTO> getMiSaldo(Principal principal) {
  if (principal == null || principal.getName() == null) {
  return ResponseEntity.status(401).build();
  String clienteEmail = principal.getName();
  SaldoPuntosDTO saldo = puntosService.getSaldoByEmail(clienteEmail);
  return ResponseEntity.ok(saldo);
  if (principal == null || principal.getName() == null) {
  return ResponseEntity.status(401).build();
  String clienteEmail = principal.getName();
  return ResponseEntity.ok(cuponGenerado);
  public ResponseEntity<ClienteFidelidadDTO> getInfoFidelidad(@PathVariable Long clienteId) {
  ClienteFidelidadDTO info = puntosService.obtenerInfoFidelidadCliente(clienteId);
  return ResponseEntity.ok(info);
  UsuarioDTO cliente = usuarioService.findById(clienteId);
  CuponDTO cupon = puntosService.canjearPuntos(cliente.getEmail(), recompensaId);
  return ResponseEntity.ok(cupon);
}
class CategoriaController {
  private CategoriaService categoriaService
  List<CategoriaDTO> categorias = categoriaService.findAll(estado);
  return ResponseEntity.ok(categorias);
  public ResponseEntity<CategoriaDTO> getCategoriaById(@PathVariable Long id) {
  CategoriaDTO categoria = categoriaService.findById(id);
  return ResponseEntity.ok(categoria);
  public ResponseEntity<CategoriaDTO> createCategoria(@Valid @RequestBody CategoriaDTO categoriaDTO) {
  CategoriaDTO nuevaCategoria = categoriaService.create(categoriaDTO);
  return new ResponseEntity<>(nuevaCategoria, HttpStatus.CREATED);
  public ResponseEntity<CategoriaDTO> updateCategoria(@PathVariable Long id, @Valid @RequestBody CategoriaDTO categoriaDTO) {
  CategoriaDTO categoriaActualizada = categoriaService.update(id, categoriaDTO);
  return ResponseEntity.ok(categoriaActualizada);
  public ResponseEntity<Map<String, String>> deleteCategoria(@PathVariable Long id) {
  categoriaService.softDelete(id);
  return ResponseEntity.ok(Map.of("message", "Categoría marcada como inactiva"));
  public ResponseEntity<Void> reactivarCategoria(@PathVariable Long id) {
  categoriaService.reactivar(id);
  return ResponseEntity.noContent().build();
}
class ReglaPuntosController {
  private ReglaPuntosService reglaPuntosService
  public ResponseEntity<ReglaPuntosDTO> getReglaActiva() {
  Optional<ReglaPuntosDTO> regla = reglaPuntosService.getReglaActivaDTO();
  return regla.map(ResponseEntity::ok)
  .orElse(ResponseEntity.notFound().build());
  public ResponseEntity<List<ReglaPuntosDTO>> getAllReglas() {
  List<ReglaPuntosDTO> reglas = reglaPuntosService.findAll();
  return ResponseEntity.ok(reglas);
  public ResponseEntity<ReglaPuntosDTO> createOrUpdateRegla(@Valid @RequestBody ReglaPuntosDTO reglaPuntosDTO) {
  ReglaPuntosDTO nuevaRegla = reglaPuntosService.createOrUpdateRegla(reglaPuntosDTO);
  return new ResponseEntity<>(nuevaRegla, HttpStatus.CREATED);
}
class MovimientoPuntosController {
  private MovimientoPuntosService movimientoPuntosService
  public List<MovimientoPuntosDTO> getAllMovimientosPuntos() {
  return movimientoPuntosService.getAllMovimientosPuntos();
  public ResponseEntity<MovimientoPuntosDTO> getMovimientoPuntosById(@PathVariable Long id) {
  return movimientoPuntosService.getMovimientoPuntosById(id)
  .map(ResponseEntity::ok)
  .orElse(ResponseEntity.notFound().build());
  public MovimientoPuntosDTO createMovimientoPuntos(@RequestBody MovimientoPuntosDTO movimientoPuntosDTO) {
  return movimientoPuntosService.createMovimientoPuntos(movimientoPuntosDTO);
  public MovimientoPuntosDTO updateMovimientoPuntos(@PathVariable Long id, @RequestBody MovimientoPuntosDTO movimientoPuntosDTO) {
  return movimientoPuntosService.updateMovimientoPuntos(id, movimientoPuntosDTO);
  public ResponseEntity<Void> deleteMovimientoPuntos(@PathVariable Long id) {
  movimientoPuntosService.deleteMovimientoPuntos(id);
  return ResponseEntity.noContent().build();
}
class UsuarioController {
  private UsuarioService usuarioService
  public ResponseEntity<UsuarioDTO> getMiPerfil(Principal principal) {
  String email = principal.getName();
  return ResponseEntity.ok(usuarioService.buscarPorEmail(email));
  public ResponseEntity<UsuarioDTO> updateMiPerfil(@Valid @RequestBody UsuarioDTO dto, Principal principal) {
  String email = principal.getName();
  return ResponseEntity.ok(usuarioService.actualizarMiPerfil(email, dto));
  public ResponseEntity<Void> cambiarPassword(@Valid @RequestBody CambioPasswordDTO dto, Principal principal) {
  String email = principal.getName();
  usuarioService.cambiarPassword(email, dto);
  return ResponseEntity.noContent().build();
  return ResponseEntity.ok(usuarioService.filtrarUsuarios(filtro, pageable));
  public ResponseEntity<UsuarioDTO> getUsuarioById(@PathVariable Long id) {
  UsuarioDTO usuario = usuarioService.findById(id);
  return ResponseEntity.ok(usuario);
  public ResponseEntity<UsuarioDTO> crearUsuario(@Valid @RequestBody UsuarioDTO usuarioDTO) {
  UsuarioDTO nuevoUsuario = usuarioService.crearUsuarioAdmin(usuarioDTO);
  return new ResponseEntity<>(nuevoUsuario, HttpStatus.CREATED);
  public ResponseEntity<UsuarioDTO> actualizarUsuario(@PathVariable Long id, @Valid @RequestBody UsuarioDTO usuarioDTO) {
  UsuarioDTO usuarioActualizado = usuarioService.actualizarUsuarioAdmin(id, usuarioDTO);
  return ResponseEntity.ok(usuarioActualizado);
  public ResponseEntity<Map<String, String>> softDeleteUsuario(@PathVariable Long id) {
  usuarioService.softDelete(id);
  return ResponseEntity.ok(Map.of("message", "Usuario marcado como inactivo"));
  public ResponseEntity<Void> reactivarUsuario(@PathVariable Long id) {
  usuarioService.reactivar(id);
  return ResponseEntity.noContent().build();
  public ResponseEntity<UsuarioDTO> registrarClienteRapido(@Valid @RequestBody UsuarioDTO usuarioDTO) {
  UsuarioDTO nuevoCliente = usuarioService.crearClienteRapido(usuarioDTO);
  return new ResponseEntity<>(nuevoCliente, HttpStatus.CREATED);
}
class PermisoController {
  private PermisoService permisoService
  public ResponseEntity<List<PermisoDTO>> getAllPermisos() {
  List<PermisoDTO> permisos = permisoService.listarPermisos();
  return ResponseEntity.ok(permisos);
  public ResponseEntity<PermisoDTO> createPermiso(@Valid @RequestBody PermisoDTO permisoDTO) {
  PermisoDTO nuevoPermiso = permisoService.crear(permisoDTO);
  return new ResponseEntity<>(nuevoPermiso, HttpStatus.CREATED);
  public ResponseEntity<PermisoDTO> updatePermiso(@PathVariable Long id, @Valid @RequestBody PermisoDTO permisoDTO) {
  permisoDTO.setId(id);
  PermisoDTO actualizado = permisoService.actualizar(permisoDTO);
  return ResponseEntity.ok(actualizado);
  public ResponseEntity<Void> deletePermiso(@PathVariable Long id) {
  permisoService.softDelete(id);
  return ResponseEntity.noContent().build();
}
class AuthController {
  private AuthService authService
  public ResponseEntity<AuthResponseDTO> login(@Valid @RequestBody LoginRequestDTO loginRequest) {
  AuthResponseDTO response = authService.login(loginRequest);
  return ResponseEntity.ok(response);
  public ResponseEntity<?> register(@Valid @RequestBody RegisterRequestDTO registerRequest) {
  authService.register(registerRequest);
  return ResponseEntity.status(HttpStatus.CREATED)
  .body(Map.of("message", "Usuario registrado exitosamente"));
  String email = principal.getName();
  authService.cambiarPasswordInicial(email, dto.getNuevaPassword());
  return ResponseEntity.ok(Map.of("message", "Contraseña actualizada correctamente"));
  public ResponseEntity<?> forgotPassword(@RequestBody Map<String, String> body) {
  String email = body.get("email");
  if (email == null || email.isBlank()) {
  return ResponseEntity.badRequest().body(Map.of("message", "El email es obligatorio"));
  authService.solicitarRecuperacionPassword(email);
  return ResponseEntity.ok(Map.of("message", "Correo de recuperación enviado (si el usuario existe)."));
  } catch (RuntimeException e) {
  return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", e.getMessage()));
  public ResponseEntity<?> resetPassword(@RequestBody Map<String, String> body) {
  String token = body.get("token");
  String password = body.get("password");
  if (token == null || password == null) {
  return ResponseEntity.badRequest().body(Map.of("message", "Token y nueva contraseña son obligatorios"));
  authService.restablecerPasswordConToken(token, password);
  return ResponseEntity.ok(Map.of("message", "Contraseña actualizada correctamente. Inicia sesión."));
  } catch (RuntimeException e) {
  return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("message", e.getMessage()));
}
class PedidoController {
  private PedidoService pedidoService
  private PdfService pdfService
  private PedidoRepository pedidoRepository
  public ResponseEntity<PedidoDTO> createPedido(@Valid @RequestBody PedidoDTO pedidoDTO) {
  PedidoDTO nuevoPedido = pedidoService.create(pedidoDTO);
  return new ResponseEntity<>(nuevoPedido, HttpStatus.CREATED);
  public ResponseEntity<Page<PedidoDTO>> getAllPedidos(Pageable pageable) {
  Page<PedidoDTO> pedidos = pedidoService.findAll(pageable);
  return ResponseEntity.ok(pedidos);
  public ResponseEntity<PedidoDTO> getPedidoById(@PathVariable Long id) {
  return ResponseEntity.ok(pedidoService.findById(id));
  public ResponseEntity<PedidoDetalladoDTO> getPedidoDetalles(@PathVariable Long id) {
  PedidoDetalladoDTO dto = pedidoService.obtenerDetallesPedido(id);
  return ResponseEntity.ok(dto);
  public ResponseEntity<byte[]> descargarComprobantePdf(@PathVariable Long id) {
  Pedido pedido = pedidoRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Pedido no encontrado: " + id));
  byte[] pdfBytes = pdfService.generarComprobantePedido(pedido);
  HttpHeaders headers = new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_PDF);
  headers.setContentDispositionFormData("inline", "pedido_" + id + ".pdf");
  return new ResponseEntity<>(pdfBytes, headers, HttpStatus.OK);
  public ResponseEntity<Void> completarPedido(@PathVariable Long id, Principal principal) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String userEmail = principal.getName();
  pedidoService.marcarPedidoCompletado(id, userEmail);
  return ResponseEntity.noContent().build();
  public ResponseEntity<Void> cancelarPedido(@PathVariable Long id) {
  pedidoService.marcarPedidoCancelado(id);
  return ResponseEntity.noContent().build();
  Page<PedidoDTO> resultado = pedidoService.filter(filtro, pageable);
  return ResponseEntity.ok(resultado);
}
class PublicController {
  private CotizacionService cotizacionService
  private PedidoRepository pedidoRepository
  private PedidoService pedidoService
  return item
  public ResponseEntity<?> getOfertaPorToken(@PathVariable String token) {
  CotizacionPublicaDTO cotizacionDTO = cotizacionService.findCotizacionPublicaByToken(token);
  return ResponseEntity.ok(cotizacionDTO);
  } catch (EntityNotFoundException e) {
  return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("status", "error", "message", e.getMessage()));
  } catch (IllegalStateException e) {
  return ResponseEntity.status(HttpStatus.GONE).body(Map.of("status", "error", "message", e.getMessage()));
  } catch (Exception e) {
  return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("status", "error", "message", "Error interno."));
  public ResponseEntity<?> submitOfertaProveedor(@PathVariable String token, @Valid @RequestBody OfertaProveedorDTO ofertaDTO) {
  cotizacionService.submitOfertaProveedor(token, ofertaDTO);
  return ResponseEntity.ok(Map.of("status", "ok", "message", "Oferta recibida exitosamente."));
  } catch (EntityNotFoundException e) {
  return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("status", "error", "message", e.getMessage()));
  } catch (IllegalStateException e) {
  return ResponseEntity.status(HttpStatus.GONE).body(Map.of("status", "error", "message", e.getMessage()));
  } catch (SecurityException e) {
  return ResponseEntity.status(HttpStatus.FORBIDDEN).body(Map.of("status", "error", "message", e.getMessage()));
  } catch (Exception e) {
  return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("status", "error", "message", "Error interno."));
  public ResponseEntity<?> getPedidoPorToken(@PathVariable String token) {
  return pedidoRepository.findByToken(token)
  .map(pedido -> {
  Map<String, Object> response = new HashMap<>();
  response.put("id", pedido.getId());
  response.put("fecha", pedido.getFechaPedido());
  response.put("estado", pedido.getEstado());
  if (pedido.getProveedor() != null) {
  response.put("proveedor", pedido.getProveedor().getRazonSocial());
  List<Map<String, Object>> detalles = pedido.getDetalles().stream().map(d -> {
  Map<String, Object> item = new HashMap<>();
  item.put("productoId", d.getProducto().getId());
  item.put("producto", d.getProducto().getNombre());
  item.put("cantidad", d.getCantidad());
  item.put("precio", d.getPrecioUnitario());
  }).collect(Collectors.toList());
  response.put("detalles", detalles);
  return ResponseEntity.ok(response);
  .orElse(ResponseEntity.notFound().build());
  public ResponseEntity<?> confirmarPedidoProveedor(@PathVariable String token, @RequestBody ConfirmacionPedidoDTO dto) {
  pedidoService.confirmarPedidoPorProveedor(token, dto);
  return ResponseEntity.ok(Map.of("status", "ok", "message", "Pedido confirmado. ¡Gracias!"));
  } catch (Exception e) {
  return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("status", "error", "message", e.getMessage()));
}
class CotizacionController {
  private CotizacionService cotizacionService
  ))
  public ResponseEntity<List<CotizacionAdminDTO>> getCotizacionesRecibidas() {
  List<CotizacionAdminDTO> cotizaciones = cotizacionService.findCotizacionesRecibidas();
  return ResponseEntity.ok(cotizaciones);
  public ResponseEntity<CotizacionAdminDTO> getCotizacionById(@PathVariable Long id) {
  CotizacionAdminDTO cotizacion = cotizacionService.findCotizacionAdminById(id);
  return ResponseEntity.ok(cotizacion);
  public ResponseEntity<Map<String, String>> cancelarItem(@PathVariable Long itemId) {
  cotizacionService.cancelarItem(itemId);
  return ResponseEntity.ok(Map.of("message", "Item cancelado correctamente."));
  public ResponseEntity<Map<String, String>> cancelarCotizacion(@PathVariable Long id) {
  cotizacionService.cancelarCotizacion(id);
  return ResponseEntity.ok(Map.of("message", "Cotización cancelada correctamente."));
  if (principal == null || principal.getName() == null) {
  return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
  Pedido pedidoGenerado = cotizacionService.confirmarCotizacion(id, principal.getName());
  "pedidoId", pedidoGenerado.getId()
  } catch (EntityNotFoundException | IllegalStateException e) {
  return ResponseEntity.badRequest().body(Map.of("message", e.getMessage()));
}
class ProveedorController {
  private ProveedorService proveedorService
  List<ProveedorDTO> proveedores = proveedorService.findAll(estado);
  return ResponseEntity.ok(proveedores);
  public ResponseEntity<ProveedorDTO> getProveedorById(@PathVariable Long id) {
  ProveedorDTO proveedor = proveedorService.findById(id);
  return ResponseEntity.ok(proveedor);
  public ResponseEntity<ProveedorDTO> createProveedor(@Valid @RequestBody ProveedorDTO proveedorDTO) {
  ProveedorDTO nuevoProveedor = proveedorService.create(proveedorDTO);
  return new ResponseEntity<>(nuevoProveedor, HttpStatus.CREATED);
  public ResponseEntity<ProveedorDTO> updateProveedor(@PathVariable Long id, @Valid @RequestBody ProveedorDTO proveedorDTO) {
  ProveedorDTO actualizado = proveedorService.update(id, proveedorDTO);
  return ResponseEntity.ok(actualizado);
  public ResponseEntity<Map<String, String>> deleteProveedor(@PathVariable Long id) {
  proveedorService.softDelete(id);
  return ResponseEntity.ok(Map.of("message", "Proveedor marcado como inactivo"));
  public ResponseEntity<Void> reactivarProveedor(@PathVariable Long id) {
  proveedorService.reactivar(id);
  return ResponseEntity.noContent().build();
}
class SolicitudProductoController {
  private SolicitudProductoRepository solicitudRepository
  private ListaEsperaRepository listaEsperaRepository
  )
  )
  return dto
  public ResponseEntity<List<SolicitudProductoDTO>> getAllSolicitudes() {
  List<SolicitudProducto> entidades = solicitudRepository.findAll(Sort.by(Sort.Direction.DESC, "fechaSolicitud"));
  List<SolicitudProductoDTO> dtos = entidades.stream()
  .map(this::mapToDTO)
  .collect(Collectors.toList());
  return ResponseEntity.ok(dtos);
  public ResponseEntity<Void> marcarComoProcesada(@PathVariable Long id) {
  return solicitudRepository.findById(id).map(solicitud -> {
  solicitud.setProcesado(true);
  solicitudRepository.save(solicitud);
  return ResponseEntity.ok().<Void>build();
  }).orElse(ResponseEntity.notFound().build());
  public ResponseEntity<Void> eliminarSolicitud(@PathVariable Long id) {
  solicitudRepository.deleteById(id);
  return ResponseEntity.noContent().build();
  private SolicitudProductoDTO mapToDTO(SolicitudProducto entity) {
  SolicitudProductoDTO dto = new SolicitudProductoDTO();
  dto.setId(entity.getId());
  dto.setDescripcion(entity.getDescripcion());
  dto.setFechaSolicitud(entity.getFechaSolicitud());
  dto.setProcesado(entity.isProcesado());
  if (entity.getUsuario() != null) {
  dto.setClienteNombre(entity.getUsuario().getNombre() + " " + entity.getUsuario().getApellido());
  dto.setClienteTelefono(entity.getUsuario().getTelefono());
  dto.setClienteEmail(entity.getUsuario().getEmail());
  if (estaEsperando) {
  dto.setEstadoListaEspera("PENDIENTE");
  dto.setEstadoListaEspera(fueNotificado ? "NOTIFICADO" : "NINGUNO");
  dto.setClienteNombre("Anónimo / No registrado");
  dto.setEstadoListaEspera("NINGUNO");
}
class CuponController {
  private CuponService cuponService
  private CuponMapper cuponMapper
  private UsuarioRepository usuarioRepository
  )
  public ResponseEntity<CuponDTO> crearCuponManual(@RequestBody CrearCuponManualDTO request) {
  request.getMotivo()
  return ResponseEntity.ok(nuevoCupon);
  Usuario cliente = usuarioRepository.findById(clienteId)
  .orElseThrow(() -> new RuntimeException("Cliente no encontrado"));
  var cuponEntidad = cuponService.validarCupon(codigo, cliente);
  return ResponseEntity.ok(cuponMapper.toCuponDTO(cuponEntidad));
}
class AuditoriaController {
  private AuditoriaService auditoriaService
  ))
  Page<Auditoria> page = auditoriaService.getLogs(pageable);
  return ResponseEntity.ok(mapToDto(page));
  Page<Auditoria> page = auditoriaService.filtrarAuditoria(filtro, pageable);
  return ResponseEntity.ok(mapToDto(page));
  private Page<AuditoriaDTO> mapToDto(Page<Auditoria> page) {
  a.getValorNuevo()
}
class CarritoController {
  private CarritoService carritoService
  public ResponseEntity<CarritoDTO> getCarrito(Principal principal) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String vendedorEmail = principal.getName();
  CarritoDTO carrito = carritoService.getCarritoByVendedorEmail(vendedorEmail);
  return ResponseEntity.ok(carrito);
  public ResponseEntity<CarritoDTO> agregarItemAlCarrito(Principal principal, @Valid @RequestBody AddItemCarritoDTO itemDTO) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String vendedorEmail = principal.getName();
  CarritoDTO carritoActualizado = carritoService.agregarItem(vendedorEmail, itemDTO);
  return ResponseEntity.ok(carritoActualizado);
  public ResponseEntity<CarritoDTO> quitarItemDelCarrito(Principal principal, @PathVariable Long itemCarritoId) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String vendedorEmail = principal.getName();
  CarritoDTO carritoActualizado = carritoService.quitarItem(vendedorEmail, itemCarritoId);
  return ResponseEntity.ok(carritoActualizado);
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String vendedorEmail = principal.getName();
  CarritoDTO carritoActualizado = carritoService.actualizarCantidadItem(vendedorEmail, itemCarritoId, cantidadDTO.getNuevaCantidad());
  return ResponseEntity.ok(carritoActualizado);
  public ResponseEntity<CarritoDTO> vaciarCarrito(Principal principal) {
  if (principal == null || principal.getName() == null) {
  return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
  String vendedorEmail = principal.getName();
  CarritoDTO carritoVacio = carritoService.vaciarCarrito(vendedorEmail);
  return ResponseEntity.ok(carritoVacio);
}
class DashboardController {
  public ResponseEntity<DashboardStatsDTO> getEstadisticasFiltradas(@RequestBody DashboardFilterDTO filtro) {
  return ResponseEntity.ok(dashboardService.getEstadisticasFiltradas(filtro.getFechaInicio(), filtro.getFechaFin()));
  public ResponseEntity<List<VentasPorDiaDTO>> getVentasSemanales() {
  return ResponseEntity.ok(dashboardService.getVentasUltimos7Dias());
  public ResponseEntity<List<VentasPorDiaDTO>> getVentasSemanalesFiltradas(@RequestBody DashboardFilterDTO filtro) {
  return ResponseEntity.ok(dashboardService.getVentasPorRango(filtro.getFechaInicio(), filtro.getFechaFin()));
  public ResponseEntity<List<TopProductoDTO>> getTopProductosFiltrados(@RequestBody DashboardFilterDTO filtro) {
  return ResponseEntity.ok(dashboardService.getTopProductosPorRango(filtro.getFechaInicio(), filtro.getFechaFin()));
  public ResponseEntity<List<TopProductoDTO>> getTopProductos() {
  return ResponseEntity.ok(dashboardService.getTop5ProductosDelMes());
  public ResponseEntity<List<VentasPorCategoriaDTO>> getVentasPorCategoria(@RequestBody DashboardFilterDTO filtro) {
  return ResponseEntity.ok(dashboardService.getVentasPorCategoria(filtro.getFechaInicio(), filtro.getFechaFin()));
  public ResponseEntity<byte[]> generarReportePdf(@RequestBody DashboardFilterDTO filtro, Principal principal) {
  String nombreResponsable = principal.getName();
  UsuarioDTO u = usuarioService.buscarPorEmail(principal.getName());
  nombreResponsable = u.getNombre() + " " + u.getApellido();
  } catch (Exception e) {
  filtro.setGeneradoPor(nombreResponsable);
  byte[] pdf = pdfService.generarReporteDashboard(filtro);
  HttpHeaders headers = new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_PDF);
  headers.setContentDispositionFormData("attachment", "reporte_dashboard.pdf");
  return ResponseEntity.ok().headers(headers).body(pdf);
  public ResponseEntity<DashboardStatsDTO> getEstadisticas() {
  return ResponseEntity.ok(dashboardService.getEstadisticas());
}
class RolController {
  private RolService rolService
  private RolMapper rolMapper
  public ResponseEntity<List<RolDTO>> getAllRoles() {
  return ResponseEntity.ok(rolService.findAll());
  public ResponseEntity<RolDTO> createRol(@Valid @RequestBody RolDTO rolDTO) {
  RolDTO nuevoRol = rolService.create(rolDTO);
  return new ResponseEntity<>(nuevoRol, HttpStatus.CREATED);
  public ResponseEntity<RolDTO> updateRol(@PathVariable Long id, @Valid @RequestBody RolDTO rolDTO) {
  RolDTO rolActualizado = rolService.update(id, rolDTO);
  return ResponseEntity.ok(rolActualizado);
  public ResponseEntity<Map<String, String>> deleteRol(@PathVariable Long id) {
  rolService.delete(id);
  return ResponseEntity.ok(Map.of("message", "Rol eliminado exitosamente"));
  public ResponseEntity<RolDTO> getRolByNombre(@RequestParam String nombre) {
  Optional<Rol> rolOptional = rolService.findByNombreRol(nombre);
  return rolOptional.map((Rol rol) -> ResponseEntity.ok(rolMapper.toRolDTO(rol)))
  .orElse(ResponseEntity.notFound().build());
}
class CatalogoController {
  private ProductoService productoService
  public ResponseEntity<Page<ProductoPublicoDTO>> getCatalogo(Pageable pageable) {
  Page<ProductoPublicoDTO> catalogo = productoService.findAllPublico(pageable);
  return ResponseEntity.ok(catalogo);
  Page<ProductoPublicoDTO> catalogo = productoService.findPublicoByCriteria(filtro, pageable);
  return ResponseEntity.ok(catalogo);
}
class HealthController {
}
class JwtAuthenticationFilter {
  private JwtTokenUtil jwtTokenUtil
  private CustomUserDetailsService userDetailsService
  return
  final String authHeader = request.getHeader("Authorization");
  if (authHeader == null || !authHeader.startsWith("Bearer ")) {
  filterChain.doFilter(request, response);
  final String jwtToken = authHeader.substring(7);
  String username = jwtTokenUtil.extractUsername(jwtToken);
  if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
  UserDetails userDetails = userDetailsService.loadUserByUsername(username);
  if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {
  userDetails, null, userDetails.getAuthorities());
  authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
  SecurityContextHolder.getContext().setAuthentication(authToken);
  } catch (Exception e) {
  System.err.println("Error procesando token JWT: " + e.getMessage());
  filterChain.doFilter(request, response);
}
OncePerRequestFilter <|-- JwtAuthenticationFilter
class JwtTokenUtil {
  private String secret
  private Long expiration
  public String extractUsername(String token) {
  return extractClaim(token, Claims::getSubject);
  public Date extractExpiration(String token) {
  return extractClaim(token, Claims::getExpiration);
  public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
  final Claims claims = extractAllClaims(token);
  return claimsResolver.apply(claims);
  private Claims extractAllClaims(String token) {
  return Jwts.parserBuilder()
  .setSigningKey(getSigningKey())
  .build()
  .parseClaimsJws(token)
  .getBody();
  private Boolean isTokenExpired(String token) {
  return extractExpiration(token).before(new Date());
  public String generateToken(Usuario usuario) {
  Map<String, Object> claims = new HashMap<>();
  claims.put("roles", usuario.getRoles().stream()
  .map(rol -> rol.getNombreRol())
  .collect(Collectors.toList()));
  claims.put("nombre", usuario.getNombre());
  claims.put("apellido", usuario.getApellido());
  claims.put("id", usuario.getId());
  return createToken(claims, usuario.getEmail());
  public String generateToken(UserDetails userDetails) {
  Map<String, Object> claims = new HashMap<>();
  return createToken(claims, userDetails.getUsername());
  private String createToken(Map<String, Object> claims, String subject) {
  return Jwts.builder()
  .setClaims(claims)
  .setSubject(subject)
  .setIssuedAt(new Date(System.currentTimeMillis()))
  .setExpiration(new Date(System.currentTimeMillis() + expiration))
  .signWith(getSigningKey(), SignatureAlgorithm.HS256)
  .compact();
  public Boolean validateToken(String token, UserDetails userDetails) {
  final String username = extractUsername(token);
  return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
  private Key getSigningKey() {
  byte[] keyBytes = Decoders.BASE64.decode(secret);
  return Keys.hmacShaKeyFor(keyBytes);
}
class VentaRealizadaEvent {
  private final Long ventaId
  this.ventaId
  return ventaId
  public VentaRealizadaEvent(Object source, Long ventaId) {
  super(source);
  public Long getVentaId() {
}
ApplicationEvent <|-- VentaRealizadaEvent
class AuditoriaListener {
  String usuario
  String idEntidad
  String valorAnterior
  String valorNuevo
  String nombreCategoria
  private void guardarLog(Object entity, String accion) {
  if (entity instanceof Auditoria) return;
  Authentication auth = SecurityContextHolder.getContext().getAuthentication();
  if (auth != null && auth.isAuthenticated() && !"anonymousUser".equals(auth.getName())) {
  usuario = auth.getName();
  String nombreEntidad = entity.getClass().getSimpleName();
  Method method = entity.getClass().getMethod("getId");
  Object idObj = method.invoke(entity);
  if (idObj != null) idEntidad = idObj.toString();
  if (entity instanceof AuditableEntity) {
  AuditableEntity auditable = (AuditableEntity) entity;
  if ("ACTUALIZAR".equals(accion)) {
  valorAnterior = auditable.getEstadoAnterior();
  valorNuevo = generarJsonSeguro(entity, mapper);
  } else if ("ELIMINAR".equals(accion)) {
  valorAnterior = generarJsonSeguro(entity, mapper);
  } else if ("CREAR".equals(accion)) {
  valorNuevo = generarJsonSeguro(entity, mapper);
  String detalleCorto = String.format("%s en %s #%s", accion, nombreEntidad, idEntidad);
  Auditoria log = new Auditoria();
  log.setEntidad(nombreEntidad);
  log.setEntidadId(idEntidad);
  log.setAccion(accion);
  log.setUsuario(usuario);
  log.setFecha(LocalDateTime.now());
  log.setDetalle(detalleCorto);
  log.setValorAnterior(valorAnterior);
  log.setValorNuevo(valorNuevo);
  service.guardar(log);
  } catch (Exception e) {
  System.err.println(">>> AUDITORIA LISTENER ERROR: " + e.getMessage());
  e.printStackTrace();
  private String generarJsonSeguro(Object entity, ObjectMapper mapper) {
  Map<String, Object> mapaDatos = mapper.convertValue(entity, new TypeReference<Map<String, Object>>() {});
  if (entity instanceof Producto) {
  Producto prod = (Producto) entity;
  if (prod.getCategoria() != null) {
  nombreCategoria = prod.getCategoria().getNombre();
  mapaDatos.put("categoria", nombreCategoria);
  return mapper.writeValueAsString(mapaDatos);
  } catch (Exception e) {
  return "{\"error\": \"No se pudo serializar: " + e.getMessage() + "\"}";
}
class FinalizarVentaDTO {
  private Long vendedorId
  private Long clienteId
}
class SolicitudProductoDTO {
  private Long id
  private String descripcion
  private LocalDateTime fechaSolicitud
  private boolean procesado
  private String clienteNombre
  private String clienteTelefono
  private String clienteEmail
  private String estadoListaEspera
}
class VentaResumenDTO {
  private Long id
  private LocalDateTime fechaVenta
  private BigDecimal totalVenta
  private EstadoVenta estado
  private String clienteNombre
  private Integer cantidadItems
  private String codigoCuponUsado
}
class VentaFiltroDTO {
  private Long clienteId
  private Long vendedorId
  private LocalDate fechaDesde
  private LocalDate fechaHasta
  private EstadoVenta estado
}
class DashboardFilterDTO {
  private LocalDate fechaInicio
  private LocalDate fechaFin
  private String graficoBase64
  private String generadoPor
}
class ClientePerfilUpdateDTO {
  private String nombre
  private String apellido
  private String telefono
  private Long tipoDocumentoId
  private String documento
}
class AuditoriaDTO {
  private Long id
  private String entidad
  private String entidadId
  private String accion
  private String usuario
  private LocalDateTime fecha
  private String detalle
  private String valorAnterior
  private String valorNuevo
}
class UsuarioFiltroDTO {
  private String nombreOEmail
  private String documento
  private Long rolId
  private EstadoUsuario estado
}
class RecompensaDTO {
  private Long id
  private String descripcion
  private int puntosRequeridos
  private TipoDescuento tipoDescuento
  private BigDecimal valor
  private Integer stock
  private Long categoriaId
  private String categoriaNombre
}
class PedidoDetalladoDTO {
  private Long id
  private LocalDateTime fechaPedido
  private EstadoPedido estado
  private BigDecimal totalPedido
  private Long proveedorId
  private String proveedorRazonSocial
  private String proveedorCuit
  private String proveedorEmail
  private String proveedorTelefono
  private String usuarioSolicitante
  private List<DetallePedidoDTO> detalles
}
class CotizacionAdminDTO {
  private Long id
  private String proveedorNombre
  private Long proveedorId
  private EstadoCotizacion estado
  private LocalDateTime fechaCreacion
  private LocalDate fechaEntregaOfertada
  private BigDecimal precioTotalOfertado
  private boolean esRecomendada
  private String observacionAnalisis
  private Set<ItemCotizacionAdminDTO> items
  return "⭐ Mejor Opción Global"
  return "❌ Precio o Fecha superior"
  public CotizacionAdminDTO(Cotizacion cotizacion) {
  this.id = cotizacion.getId();
  this.proveedorNombre = cotizacion.getProveedor().getRazonSocial();
  this.proveedorId = cotizacion.getProveedor().getId();
  this.estado = cotizacion.getEstado();
  this.fechaCreacion = cotizacion.getFechaCreacion();
  this.fechaEntregaOfertada = cotizacion.getFechaEntregaOfertada();
  this.precioTotalOfertado = cotizacion.getPrecioTotalOfertado();
  this.esRecomendada = cotizacion.isEsRecomendada();
  this.observacionAnalisis = calcularObservacion(cotizacion);
  this.items = cotizacion.getItems().stream()
  .map(ItemCotizacionAdminDTO::new)
  .collect(Collectors.toSet());
  private String calcularObservacion(Cotizacion c) {
  long itemsCotizados = c.getItems().stream()
  .filter(i -> i.getEstado() == EstadoItemCotizacion.COTIZADO).count();
  int totalItems = c.getItems().size();
  if (itemsCotizados < totalItems) {
  return "⚠️ Oferta Incompleta (" + itemsCotizados + "/" + totalItems + " items)";
  if (c.isEsRecomendada()) {
}
class ClienteFidelidadDTO {
  private Long clienteId
  private String nombreCompleto
  private Integer puntosAcumulados
  private String equivalenciaMonetaria
  private List<CuponDTO> cuponesDisponibles
  private List<RecompensaDTO> recompensasAlcanzables
}
class SaldoPuntosDTO {
  private int saldoPuntos
  private BigDecimal valorMonetario
  private String equivalenciaActual
  private List<RecompensaDTO> recompensasDisponibles
}
class CambioPasswordDTO {
  private String passwordActual
  private String passwordNueva
}
class VentaDTO {
  private Long id
  private LocalDateTime fechaVenta
  private EstadoVenta estado
  private BigDecimal totalVenta
  private Long clienteId
  private String clienteNombre
  private Long vendedorId
  private String vendedorNombre
  private LocalDateTime fechaCreacion
  private LocalDateTime fechaModificacion
  private String codigoCupon
  private BigDecimal montoDescuento
  private List<DetalleVentaDTO> detalles
  private byte[] comprobantePdf
}
class ItemCotizacionAdminDTO {
  private Long id
  private Long productoId
  private String productoNombre
  private int cantidadSolicitada
  private EstadoItemCotizacion estado
  private BigDecimal precioUnitarioOfertado
  private BigDecimal subtotalOfertado
  )
  this.subtotalOfertado
  public ItemCotizacionAdminDTO(ItemCotizacion item) {
  this.id = item.getId();
  this.productoId = item.getProducto().getId();
  this.productoNombre = item.getProducto().getNombre();
  this.cantidadSolicitada = item.getCantidadSolicitada();
  this.estado = item.getEstado();
  this.precioUnitarioOfertado = item.getPrecioUnitarioOfertado();
  if (this.precioUnitarioOfertado != null) {
  new BigDecimal(this.cantidadSolicitada)
}
class ClientePerfilDTO {
  private Long id
  private String email
  private String nombre
  private String apellido
  private String telefono
  private Long tipoDocumentoId
  private String tipoDocumento
  private String documento
}
class CategoriaDTO {
  private Long id
  private String nombre
  private String descripcion
  private String estado
}
class MovimientoPuntosDTO {
  private Long id
  private Integer puntos
  private TipoMovimientoPuntos tipoMovimiento
  private LocalDateTime fechaCaducidadPuntos
  private String descripcion
  private Long cuentaPuntosId
  private Long ventaId
}
class AddListaEsperaDTO {
  private Long usuarioId
  private Long productoId
}
class DetallePedidoDTO {
  private Long id
  private Long productoId
  private String productoNombre
  private String productoCodigo
  private int cantidad
  private BigDecimal precioUnitario
  private BigDecimal subtotal
}
class CanjePuntosRequestDTO {
  private Long recompensaId
}
class CuponDTO {
  private Long id
  private String codigo
  private LocalDate fechaVencimiento
  private EstadoCupon estado
  private String clienteEmail
  private BigDecimal valor
  private TipoDescuento tipoDescuento
  private Long categoriaId
  private String categoriaNombre
}
class RolDTO {
  private Long id
  private String nombreRol
  private String descripcion
  private List<PermisoDTO> permisos
}
class UpdateCantidadCarritoDTO {
  private Integer nuevaCantidad
}
class CrearCuponManualDTO {
  private Long usuarioId
  private BigDecimal valor
  private TipoDescuento tipoDescuento
  private int diasValidez
  private String motivo
}
class UsuarioDTO {
  private Long id
  private String nombre
  private String apellido
  private String email
  private String passwordHash
  private String documento
  private String telefono
  private EstadoUsuario estado
  private Long tipoDocumentoId
  private String tipoDocumentoNombre
  private Long idTipoDocumento
  private String tipoDocumentoBusqueda
  private LocalDateTime fechaCreacion
  private LocalDateTime fechaModificacion
  private List<RolDTO> roles
}
class ConfirmacionPedidoDTO {
  private LocalDate fechaEntrega
  private List<ItemConfirmacionDTO> items
  private Long productoId
  private BigDecimal nuevoPrecio
}
class ItemConfirmacionDTO {
  private Long productoId
  private BigDecimal nuevoPrecio
}
class TwilioRequestDTO {
  private String from
  private String body
}
class TopProductoDTO {
  private Long productoId
  private String nombre
  private Long cantidadVendida
}
class ReglaPuntosDTO {
  private Long id
  private String descripcion
  private BigDecimal montoGasto
  private Integer puntosGanados
  private BigDecimal equivalenciaPuntos
  private String estadoRegla
  private Integer caducidadPuntosMeses
  private LocalDateTime fechaInicioVigencia
}
AuditableDTO <|-- ReglaPuntosDTO
class ProveedorDTO {
  private Long id
  private String razonSocial
  private String cuit
  private String email
  private String telefono
  private String direccion
  private String estado
  private Set<Long> categoriaIds
}
AuditableDTO <|-- ProveedorDTO
class OfertaProveedorDTO {
  private LocalDate fechaEntregaOfertada
  private List<ItemOfertaDTO> items
}
class MovimientoStockDTO {
  private Long productoId
  private Long usuarioId
  private TipoMovimiento tipoMovimiento
  private int cantidad
  private String motivo
  private Long ventaId
  private Long pedidoId
}
class ProductoPublicoDTO {
  private Long id
  private String nombre
  private String codigo
  private String descripcion
  private BigDecimal precioVenta
  private Integer stockActual
  private String imagenUrl
  private String nombreCategoria
  private int stockMinimo
}
class ItemOfertaDTO {
  private Long itemCotizacionId
  private BigDecimal precioUnitarioOfertado
  private Integer cantidadOfertada
  private boolean disponible
}
class DashboardStatsDTO {
  private BigDecimal totalVentasMes
  private long productosBajoStock
  private long clientesActivos
  private BigDecimal totalVentasHoy
  private long cantidadVentasPeriodo
  private List<PedidoEnCaminoDTO> pedidosEnCamino
  private String proveedor
  private LocalDate fechaEntrega
  private Long diasRestantes
}
class PedidoEnCaminoDTO {
  private String proveedor
  private LocalDate fechaEntrega
  private Long diasRestantes
}
class AuditableDTO {
  private LocalDateTime fechaCreacion
  private LocalDateTime fechaModificacion
}
class ProductoPublicoFiltroDTO {
  private String nombre
  private List<Long> categoriaIds
  private BigDecimal precioMin
  private BigDecimal precioMax
  private Boolean soloConStock
}
class PermisoDTO {
  private Long id
  private String nombrePermiso
  private String descripcion
}
class ItemCotizacionPublicoDTO {
  private Long id
  private String productoNombre
  private String productoCodigo
  private int cantidadSolicitada
  private BigDecimal precioUnitarioOfertado
  this.precioUnitarioOfertado
  public ItemCotizacionPublicoDTO(ItemCotizacion item) {
  this.id = item.getId();
  this.productoNombre = item.getProducto().getNombre();
  this.productoCodigo = item.getProducto().getCodigo();
  this.cantidadSolicitada = item.getCantidadSolicitada();
}
class DetalleVentaDTO {
  private Long id
  private String productoNombre
  private String productoCodigo
  private BigDecimal precioUnitario
  private BigDecimal subtotal
  private Long productoId
  private Integer cantidad
}
class ProductoFiltroDTO {
  private String nombre
  private String codigo
  private Long categoriaId
  private BigDecimal precioMax
  private Boolean conStock
  private String estado
  private String estadoStock
  private List<Long> categoriaIds
  private BigDecimal precioMin
  private Boolean soloConStock
}
class CotizacionPublicaDTO {
  private String token
  private String proveedorNombre
  private LocalDate fechaSolicitud
  private List<ItemCotizacionPublicoDTO> items
  private LocalDate fechaEntregaOfertada
  this.fechaEntregaOfertada
  public CotizacionPublicaDTO(Cotizacion cotizacion) {
  this.token = cotizacion.getToken();
  this.proveedorNombre = cotizacion.getProveedor().getRazonSocial();
  this.fechaSolicitud = cotizacion.getFechaCreacion().toLocalDate();
  this.items = cotizacion.getItems().stream()
  .filter(item -> item.getEstado() == com.masterserv.productos.enums.EstadoItemCotizacion.PENDIENTE)
  .map(ItemCotizacionPublicoDTO::new)
  .collect(Collectors.toList());
}
class ClienteDTO {
  private Long id
  private String nombre
  private String apellido
  private String email
  private String documento
  private String telefono
  private String tipoDocumentoBusqueda
  private Long tipoDocumentoId
}
class AddItemCarritoDTO {
  private Long productoId
  private Integer cantidad
  return this.productoId
  public Long getProductoId() {
}
class PedidoDTO {
  private Long id
  private Long proveedorId
  private Long usuarioId
  private String proveedorRazonSocial
  private String usuarioNombre
  private LocalDateTime fechaPedido
  private EstadoPedido estado
  private BigDecimal totalPedido
  private String token
  private Set<DetallePedidoDTO> detalles
}
AuditableDTO <|-- PedidoDTO
class AuditoriaFiltroDTO {
  private String usuario
  private String accion
  private String entidad
  private LocalDate fechaDesde
  private LocalDate fechaHasta
  private Long entidadId
}
class VentasPorCategoriaDTO {
  private String categoria
  private BigDecimal total
}
class PedidoFiltroDTO {
  private Long proveedorId
  private Long usuarioId
  private EstadoPedido estado
  private LocalDate fechaDesde
  private LocalDate fechaHasta
}
class ItemCarritoDTO {
  private Long id
  private Long productoId
  private String productoNombre
  private String productoCodigo
  private BigDecimal precioUnitarioVenta
  private int cantidad
  private BigDecimal subtotal
  private int stockDisponible
  private Long productoCategoriaId
}
class CarritoDTO {
  private Long id
  private Long vendedorId
  private List<ItemCarritoDTO> items
  private BigDecimal totalCarrito
  private int cantidadItems
  public void setFechaModificacion(LocalDateTime fechaModificacion) {
  throw new UnsupportedOperationException("Unimplemented method 'setFechaModificacion'");
  public void setFechaCreacion(LocalDateTime fechaCreacion) {
  throw new UnsupportedOperationException("Unimplemented method 'setFechaCreacion'");
}
class LoginRequestDTO {
  private String email
  private String password
}
class CambiarPasswordDTO {
  private String nuevaPassword
}
class RegisterRequestDTO {
  private String nombre
  private String apellido
  private String email
  private String password
  private Long tipoDocumentoId
  private String documento
  private String telefono
}
class AuthResponseDTO {
  private String token
  private Long usuarioId
  private String email
  private List<String> roles
  private List<String> permisos
  private boolean debeCambiarPassword
}
class AuditoriaSpecification {
  }
  public Specification<Auditoria> getByFilters(AuditoriaFiltroDTO filtro) {
  return (root, query, criteriaBuilder) -> {
  List<Predicate> predicates = new ArrayList<>();
  if (filtro.getUsuario() != null && !filtro.getUsuario().isBlank()) {
  String term = "%" + filtro.getUsuario().toLowerCase() + "%";
  predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("usuario")), term));
  if (filtro.getAccion() != null && !filtro.getAccion().isBlank()) {
  predicates.add(criteriaBuilder.equal(root.get("accion"), filtro.getAccion()));
  if (filtro.getEntidad() != null && !filtro.getEntidad().isBlank()) {
  predicates.add(criteriaBuilder.equal(root.get("entidad"), filtro.getEntidad()));
  if (filtro.getFechaDesde() != null) {
  predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("fecha"), filtro.getFechaDesde().atStartOfDay()));
  if (filtro.getFechaHasta() != null) {
  predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("fecha"), filtro.getFechaHasta().atTime(23, 59, 59)));
  query.orderBy(criteriaBuilder.desc(root.get("fecha")));
  return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
}
class PedidoSpecification {
  }
  public Specification<Pedido> getByFilters(PedidoFiltroDTO filtro) {
  return (root, query, criteriaBuilder) -> {
  List<Predicate> predicates = new ArrayList<>();
  if (filtro.getProveedorId() != null) {
  predicates.add(criteriaBuilder.equal(root.get("proveedor").get("id"), filtro.getProveedorId()));
  if (filtro.getUsuarioId() != null) {
  predicates.add(criteriaBuilder.equal(root.get("usuario").get("id"), filtro.getUsuarioId()));
  if (filtro.getEstado() != null) {
  predicates.add(criteriaBuilder.equal(root.get("estado"), filtro.getEstado()));
  if (filtro.getFechaDesde() != null) {
  predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("fechaPedido"), filtro.getFechaDesde().atStartOfDay()));
  if (filtro.getFechaHasta() != null) {
  predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("fechaPedido"), filtro.getFechaHasta().atTime(23, 59, 59)));
  query.orderBy(criteriaBuilder.desc(root.get("fechaPedido")));
  return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
}
class ProductoSpecification {
  break
  break
  break
  default: break
  }
  public Specification<Producto> getProductosByFilters(ProductoFiltroDTO filtro) {
  return (root, query, cb) -> {
  List<Predicate> predicates = new ArrayList<>();
  if (filtro.getEstado() != null && !filtro.getEstado().isEmpty()) {
  if (!filtro.getEstado().equalsIgnoreCase("TODOS")) {
  predicates.add(cb.equal(root.get("estado"), filtro.getEstado()));
  predicates.add(cb.equal(root.get("estado"), "ACTIVO"));
  if (filtro.getNombre() != null && !filtro.getNombre().isEmpty()) {
  predicates.add(cb.like(cb.lower(root.get("nombre")), "%" + filtro.getNombre().toLowerCase() + "%"));
  if (filtro.getCodigo() != null && !filtro.getCodigo().isEmpty()) {
  predicates.add(cb.like(cb.lower(root.get("codigo")), "%" + filtro.getCodigo().toLowerCase() + "%"));
  if (filtro.getCategoriaId() != null) {
  predicates.add(cb.equal(root.get("categoria").get("id"), filtro.getCategoriaId()));
  if (!CollectionUtils.isEmpty(filtro.getCategoriaIds())) {
  predicates.add(root.get("categoria").get("id").in(filtro.getCategoriaIds()));
  if (filtro.getPrecioMin() != null) {
  predicates.add(cb.greaterThanOrEqualTo(root.get("precioVenta"), filtro.getPrecioMin()));
  if (filtro.getPrecioMax() != null) {
  predicates.add(cb.lessThanOrEqualTo(root.get("precioVenta"), filtro.getPrecioMax()));
  if (filtro.getEstadoStock() != null) {
  switch (filtro.getEstadoStock()) {
  predicates.add(cb.greaterThan(root.get("stockActual"), 0));
  predicates.add(cb.equal(root.get("stockActual"), 0));
  predicates.add(cb.lessThanOrEqualTo(root.get("stockActual"), root.get("stockMinimo")));
  else if (Boolean.TRUE.equals(filtro.getSoloConStock()) || Boolean.TRUE.equals(filtro.getConStock())) {
  predicates.add(cb.greaterThan(root.get("stockActual"), 0));
  } else if (Boolean.FALSE.equals(filtro.getConStock())) {
  predicates.add(cb.equal(root.get("stockActual"), 0));
  return cb.and(predicates.toArray(new Predicate[0]));
}
class UsuarioSpecification {
  ))
  }
  public Specification<Usuario> getUsuariosByFilters(UsuarioFiltroDTO filtro) {
  return (root, query, cb) -> {
  List<Predicate> predicates = new ArrayList<>();
  if (filtro.getNombreOEmail() != null && !filtro.getNombreOEmail().isEmpty()) {
  String busquedaLower = "%" + filtro.getNombreOEmail().toLowerCase() + "%";
  String busquedaNormal = "%" + filtro.getNombreOEmail() + "%";
  cb.like(root.get("documento"), busquedaNormal)
  if (filtro.getDocumento() != null && !filtro.getDocumento().isEmpty()) {
  predicates.add(cb.like(root.get("documento"), "%" + filtro.getDocumento() + "%"));
  if (filtro.getEstado() != null) {
  predicates.add(cb.equal(root.get("estado"), filtro.getEstado()));
  if (filtro.getRolId() != null) {
  Join<Usuario, Rol> rolJoin = root.join("roles");
  predicates.add(cb.equal(rolJoin.get("id"), filtro.getRolId()));
  query.distinct(true);
  return cb.and(predicates.toArray(new Predicate[0]));
}
class VentaSpecification {
  }
  public Specification<Venta> build(VentaFiltroDTO filtro) {
  return (Root<Venta> root, CriteriaQuery<?> query, CriteriaBuilder cb) -> {
  List<Predicate> predicates = new ArrayList<>();
  if (filtro.getClienteId() != null) {
  Join<Venta, Usuario> clienteJoin = root.join("cliente", JoinType.INNER);
  predicates.add(cb.equal(clienteJoin.get("id"), filtro.getClienteId()));
  if (filtro.getVendedorId() != null) {
  Join<Venta, Usuario> vendedorJoin = root.join("vendedor", JoinType.INNER);
  predicates.add(cb.equal(vendedorJoin.get("id"), filtro.getVendedorId()));
  if (filtro.getFechaDesde() != null) {
  LocalDateTime fechaDesdeInicioDia = filtro.getFechaDesde().atStartOfDay();
  predicates.add(cb.greaterThanOrEqualTo(root.get("fechaVenta"), fechaDesdeInicioDia));
  if (filtro.getFechaHasta() != null) {
  LocalDateTime fechaHastaFinDia = filtro.getFechaHasta().plusDays(1).atStartOfDay();
  predicates.add(cb.lessThan(root.get("fechaVenta"), fechaHastaFinDia));
  if (filtro.getEstado() != null) {
  predicates.add(cb.equal(root.get("estado"), filtro.getEstado()));
  return cb.and(predicates.toArray(new Predicate[0]));
}
class UsuarioService {
  boolean esCliente
  esCliente
  public UsuarioDTO buscarPorEmail(String email) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado: " + email));
  return usuarioMapper.toUsuarioDTO(usuario);
  public UsuarioDTO actualizarMiPerfil(String email, UsuarioDTO dto) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado: " + email));
  usuario.setNombre(dto.getNombre());
  usuario.setApellido(dto.getApellido());
  usuario.setTelefono(dto.getTelefono());
  usuario.setDocumento(dto.getDocumento());
  if (dto.getTipoDocumentoId() != null) {
  TipoDocumento td = tipoDocumentoRepository.findById(dto.getTipoDocumentoId())
  .orElseThrow(() -> new RuntimeException("Tipo de documento inválido"));
  usuario.setTipoDocumento(td);
  Usuario guardado = usuarioRepository.save(usuario);
  return usuarioMapper.toUsuarioDTO(guardado);
  public void cambiarPassword(String email, CambioPasswordDTO dto) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado: " + email));
  if (!passwordEncoder.matches(dto.getPasswordActual(), usuario.getPasswordHash())) {
  throw new RuntimeException("La contraseña actual es incorrecta.");
  usuario.setPasswordHash(passwordEncoder.encode(dto.getPasswordNueva()));
  usuarioRepository.save(usuario);
  public Page<UsuarioDTO> filtrarUsuarios(UsuarioFiltroDTO filtro, Pageable pageable) {
  Specification<Usuario> spec = usuarioSpecification.getUsuariosByFilters(filtro);
  Page<Usuario> usuariosPage = usuarioRepository.findAll(spec, pageable);
  return usuariosPage.map(usuarioMapper::toUsuarioDTO);
  public UsuarioDTO findById(Long id) {
  Usuario usuario = usuarioRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado con ID: " + id));
  return usuarioMapper.toUsuarioDTO(usuario);
  public UsuarioDTO crearUsuarioAdmin(UsuarioDTO usuarioDTO) {
  if (usuarioRepository.existsByEmail(usuarioDTO.getEmail())) {
  throw new RuntimeException("El email ya está registrado.");
  Usuario usuario = usuarioMapper.toUsuario(usuarioDTO);
  if (usuarioDTO.getPasswordHash() == null || usuarioDTO.getPasswordHash().isEmpty()) {
  throw new RuntimeException("La contraseña es obligatoria al crear un usuario.");
  usuario.setPasswordHash(passwordEncoder.encode(usuarioDTO.getPasswordHash()));
  if (usuarioDTO.getTipoDocumentoId() != null) {
  TipoDocumento tipoDoc = tipoDocumentoRepository.findById(usuarioDTO.getTipoDocumentoId())
  .orElseThrow(() -> new RuntimeException("Tipo de Documento no encontrado."));
  usuario.setTipoDocumento(tipoDoc);
  if (usuarioDTO.getRoles() == null || usuarioDTO.getRoles().isEmpty()) {
  throw new RuntimeException("Se debe asignar al menos un rol.");
  Set<Rol> roles = new HashSet<>();
  for (RolDTO rolDto : usuarioDTO.getRoles()) {
  Rol rol = rolRepository.findById(rolDto.getId())
  .orElseThrow(() -> new RuntimeException("Rol no encontrado: " + rolDto.getId()));
  roles.add(rol);
  String nombreRol = rol.getNombreRol().toUpperCase();
  if (nombreRol.equals("ROLE_CLIENTE") || nombreRol.equals("CLIENTE")) {
  usuario.setRoles(roles);
  usuario.setEstado(usuarioDTO.getEstado() != null ? usuarioDTO.getEstado() : EstadoUsuario.ACTIVO);
  usuario.setFechaCreacion(LocalDateTime.now());
  Usuario nuevoUsuario = usuarioRepository.save(usuario);
  if (esCliente) {
  if (!cuentaPuntosRepository.existsByClienteId(nuevoUsuario.getId())) {
  CuentaPuntos nuevaCuenta = new CuentaPuntos();
  nuevaCuenta.setCliente(nuevoUsuario);
  nuevaCuenta.setSaldoPuntos(0);
  cuentaPuntosRepository.save(nuevaCuenta);
  return usuarioMapper.toUsuarioDTO(nuevoUsuario);
  public UsuarioDTO actualizarUsuarioAdmin(Long id, UsuarioDTO usuarioDTO) {
  Usuario usuarioExistente = usuarioRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado con ID: " + id));
  usuarioMapper.updateUsuarioFromDto(usuarioDTO, usuarioExistente);
  if (usuarioDTO.getPasswordHash() != null && !usuarioDTO.getPasswordHash().isEmpty()) {
  if (usuarioDTO.getPasswordHash().length() < 8) {
  throw new RuntimeException("La nueva contraseña debe tener al menos 8 caracteres.");
  usuarioExistente.setPasswordHash(passwordEncoder.encode(usuarioDTO.getPasswordHash()));
  if (usuarioDTO.getTipoDocumentoId() != null) {
  TipoDocumento tipoDoc = tipoDocumentoRepository.findById(usuarioDTO.getTipoDocumentoId())
  .orElseThrow(() -> new RuntimeException("Tipo de Documento no encontrado."));
  usuarioExistente.setTipoDocumento(tipoDoc);
  usuarioExistente.setTipoDocumento(null);
  if (usuarioDTO.getRoles() != null && !usuarioDTO.getRoles().isEmpty()) {
  Set<Rol> roles = usuarioDTO.getRoles().stream()
  .map(rolDto -> rolRepository.findById(rolDto.getId())
  .orElseThrow(() -> new RuntimeException("Rol no encontrado: " + rolDto.getId())))
  .collect(java.util.stream.Collectors.toSet());
  usuarioExistente.setRoles(roles);
  usuarioExistente.getRoles().clear();
  if(usuarioDTO.getEstado() != null) {
  usuarioExistente.setEstado(usuarioDTO.getEstado());
  Usuario usuarioActualizado = usuarioRepository.save(usuarioExistente);
  return usuarioMapper.toUsuarioDTO(usuarioActualizado);
  public void softDelete(Long id) {
  Usuario usuario = usuarioRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado con ID: " + id));
  usuario.setEstado(EstadoUsuario.INACTIVO);
  usuarioRepository.save(usuario);
  public void reactivar(Long id) {
  Usuario usuario = usuarioRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado con ID: " + id));
  usuario.setEstado(EstadoUsuario.ACTIVO);
  usuarioRepository.save(usuario);
  public UsuarioDTO crearClienteRapido(UsuarioDTO dto) {
  if (usuarioRepository.existsByEmail(dto.getEmail())) {
  throw new RuntimeException("El email ya está registrado.");
  Usuario usuario = new Usuario();
  usuario.setNombre(dto.getNombre());
  usuario.setApellido(dto.getApellido());
  usuario.setDocumento(dto.getDocumento());
  usuario.setEmail(dto.getEmail());
  usuario.setTelefono(dto.getTelefono());
  usuario.setEstado(EstadoUsuario.ACTIVO);
  usuario.setFechaCreacion(LocalDateTime.now());
  if (dto.getTipoDocumentoBusqueda() != null) {
  TipoDocumento tipoDoc = tipoDocumentoRepository.findByNombreCorto(dto.getTipoDocumentoBusqueda())
  .orElseThrow(() -> new RuntimeException("Tipo de documento '" + dto.getTipoDocumentoBusqueda() + "' no encontrado."));
  usuario.setTipoDocumento(tipoDoc);
  else if (dto.getTipoDocumentoId() != null) {
  TipoDocumento tipoDoc = tipoDocumentoRepository.findById(dto.getTipoDocumentoId())
  .orElseThrow(() -> new RuntimeException("Tipo de documento inválido (ID no encontrado)"));
  usuario.setTipoDocumento(tipoDoc);
  usuario.setPasswordHash(passwordEncoder.encode("123456"));
  Optional<Rol> rolOpt = rolRepository.findByNombreRol("ROLE_CLIENTE");
  if (rolOpt.isEmpty()) {
  rolOpt = rolRepository.findByNombreRol("CLIENTE");
  Rol rolCliente = rolOpt.orElseThrow(() -> new RuntimeException("Error crítico: Rol CLIENTE no encontrado."));
  Set<Rol> roles = new HashSet<>();
  roles.add(rolCliente);
  usuario.setRoles(roles);
  Usuario guardado = usuarioRepository.save(usuario);
  if (!cuentaPuntosRepository.existsByClienteId(guardado.getId())) {
  CuentaPuntos nuevaCuenta = new CuentaPuntos();
  nuevaCuenta.setCliente(guardado);
  nuevaCuenta.setSaldoPuntos(0);
  cuentaPuntosRepository.save(nuevaCuenta);
  return usuarioMapper.toUsuarioDTO(guardado);
}
class PuntosService {
  private ReglaPuntosService reglaPuntosService
  private CuentaPuntosRepository cuentaPuntosRepository
  private MovimientoPuntosRepository movimientoPuntosRepository
  private CuponRepository cuponRepository
  private UsuarioRepository usuarioRepository
  private CuponMapper cuponMapper
  private RecompensaRepository recompensaRepository
  private RecompensaMapper recompensaMapper
  private CuponService cuponService
  ". Motivo: No hay regla de puntos ACTIVA configurada.")
  return
  return
  })
  return
  )
  return 0
  return
  )
  return
  )
  return
  ))
  ))
  return saldoDTO
  return saldoDTO
  )
  String equivalencia
  return dto
  public void asignarPuntosPorVenta(Venta venta) {
  Optional<ReglaPuntos> reglaOpt = reglaPuntosService.getReglaActiva();
  if (reglaOpt.isEmpty()) {
  ReglaPuntos regla = reglaOpt.get();
  Usuario cliente = venta.getCliente();
  if (cliente == null) {
  System.err.println("WARN: No se asignaron puntos. La Venta #" + venta.getId() + " no tiene cliente asociado.");
  CuentaPuntos cuenta = cuentaPuntosRepository.findByCliente(cliente)
  .orElseGet(() -> {
  CuentaPuntos nuevaCuenta = new CuentaPuntos();
  nuevaCuenta.setCliente(cliente);
  nuevaCuenta.setSaldoPuntos(0);
  return cuentaPuntosRepository.save(nuevaCuenta);
  int puntosGanados = calcularPuntos(venta.getTotalVenta(), regla);
  if (puntosGanados <= 0) {
  MovimientoPuntos movimiento = new MovimientoPuntos();
  movimiento.setPuntos(puntosGanados);
  movimiento.setTipoMovimiento(TipoMovimientoPuntos.GANADO);
  movimiento.setDescripcion("Puntos ganados por Venta #" + venta.getId());
  movimiento.setCuentaPuntos(cuenta);
  movimiento.setVenta(venta);
  if (regla.getCaducidadPuntosMeses() != null && regla.getCaducidadPuntosMeses() > 0) {
  LocalDateTime.now().plusMonths(regla.getCaducidadPuntosMeses())
  cuenta.setSaldoPuntos(cuenta.getSaldoPuntos() + puntosGanados);
  cuentaPuntosRepository.save(cuenta);
  movimientoPuntosRepository.save(movimiento);
  private int calcularPuntos(BigDecimal totalVenta, ReglaPuntos regla) {
  if (regla.getMontoGasto() == null || regla.getMontoGasto().compareTo(BigDecimal.ZERO) <= 0) {
  BigDecimal puntosDecimal = totalVenta.divide(regla.getMontoGasto(), 0, RoundingMode.FLOOR);
  return puntosDecimal.multiply(new BigDecimal(regla.getPuntosGanados())).intValue();
  public void revertirPuntosPorVenta(Venta venta) {
  if (venta.getEstado() != EstadoVenta.CANCELADA) {
  System.err.println("WARN: Se intentó revertir puntos de una venta no cancelada. Venta #" + venta.getId());
  if (yaRevertido) {
  System.out.println("INFO: Los puntos para la Venta #" + venta.getId() + " ya habían sido revertidos.");
  if (movOriginalOpt.isEmpty()) {
  System.out.println("INFO: La Venta #" + venta.getId() + " no generó puntos. No se revierte nada.");
  MovimientoPuntos movOriginal = movOriginalOpt.get();
  CuentaPuntos cuenta = movOriginal.getCuentaPuntos();
  int puntosARevertir = movOriginal.getPuntos();
  MovimientoPuntos movReversion = new MovimientoPuntos();
  movReversion.setPuntos(-puntosARevertir);
  movReversion.setTipoMovimiento(TipoMovimientoPuntos.REVERSION);
  movReversion.setDescripcion("Reversión por cancelación Venta #" + venta.getId());
  movReversion.setCuentaPuntos(cuenta);
  movReversion.setVenta(venta);
  cuenta.setSaldoPuntos(cuenta.getSaldoPuntos() - puntosARevertir);
  cuentaPuntosRepository.save(cuenta);
  movimientoPuntosRepository.save(movReversion);
  System.out.println("INFO: Revertidos " + puntosARevertir + " puntos de la Venta #" + venta.getId());
  public CuponDTO canjearPuntos(String clienteEmail, Long recompensaId) {
  Recompensa recompensa = recompensaRepository.findById(recompensaId)
  .orElseThrow(() -> new RuntimeException("La recompensa seleccionada no existe."));
  if (recompensa.getStock() <= 0) {
  throw new RuntimeException("Lo sentimos, esta recompensa se ha agotado (Stock 0).");
  int puntosRequeridos = recompensa.getPuntosRequeridos();
  CuentaPuntos cuenta = cuentaPuntosRepository.findByCliente_Email(clienteEmail)
  .orElseThrow(() -> new RuntimeException("No se encontró una cuenta de puntos para el cliente: " + clienteEmail));
  if (cuenta.getSaldoPuntos() < puntosRequeridos) {
  recompensa.setStock(recompensa.getStock() - 1);
  recompensaRepository.save(recompensa);
  MovimientoPuntos movimiento = new MovimientoPuntos();
  movimiento.setPuntos(-puntosRequeridos);
  movimiento.setTipoMovimiento(TipoMovimientoPuntos.CANJEADO);
  "Canje por recompensa: %s", recompensa.getDescripcion()
  movimiento.setCuentaPuntos(cuenta);
  cuenta.setSaldoPuntos(cuenta.getSaldoPuntos() - puntosRequeridos);
  cuentaPuntosRepository.save(cuenta);
  movimientoPuntosRepository.save(movimiento);
  Cupon cuponGuardado = cuponService.crearCuponPorCanje(cuenta.getCliente(), recompensa);
  return cuponMapper.toCuponDTO(cuponGuardado);
  public SaldoPuntosDTO getSaldoByEmail(String clienteEmail) {
  SaldoPuntosDTO saldoDTO = new SaldoPuntosDTO();
  Optional<CuentaPuntos> cuentaOpt = cuentaPuntosRepository.findByCliente_Email(clienteEmail);
  if (cuentaOpt.isEmpty()) {
  saldoDTO.setSaldoPuntos(0);
  saldoDTO.setValorMonetario(BigDecimal.ZERO);
  saldoDTO.setEquivalenciaActual("N/A");
  saldoDTO.setRecompensasDisponibles(new ArrayList<>());
  CuentaPuntos cuenta = cuentaOpt.get();
  saldoDTO.setSaldoPuntos(cuenta.getSaldoPuntos());
  Optional<ReglaPuntos> reglaOpt = reglaPuntosService.getReglaActiva();
  if (reglaOpt.isPresent()) {
  ReglaPuntos regla = reglaOpt.get();
  if (regla.getEquivalenciaPuntos() != null && regla.getEquivalenciaPuntos().compareTo(BigDecimal.ZERO) > 0) {
  BigDecimal valorMonetario = regla.getEquivalenciaPuntos()
  .multiply(new BigDecimal(cuenta.getSaldoPuntos()));
  valorMonetario = valorMonetario.setScale(2, RoundingMode.HALF_UP);
  saldoDTO.setValorMonetario(valorMonetario);
  String equivalenciaStr = String.format("1 Punto = $%.2f ARS", regla.getEquivalenciaPuntos());
  saldoDTO.setEquivalenciaActual(equivalenciaStr);
  saldoDTO.setValorMonetario(BigDecimal.ZERO);
  saldoDTO.setEquivalenciaActual("Ver catálogo de canjes");
  saldoDTO.setValorMonetario(BigDecimal.ZERO);
  saldoDTO.setEquivalenciaActual("Sin regla activa");
  List<Recompensa> recompensasActivas = recompensaRepository.findAll().stream()
  .filter(r -> Boolean.TRUE.equals(r.getActivo()) && r.getStock() > 0)
  .collect(Collectors.toList());
  List<RecompensaDTO> recompensasDTO = recompensasActivas.stream()
  .map(recompensaMapper::toDto)
  .collect(Collectors.toList());
  saldoDTO.setRecompensasDisponibles(recompensasDTO);
  public ClienteFidelidadDTO obtenerInfoFidelidadCliente(Long clienteId) {
  Usuario cliente = usuarioRepository.findById(clienteId)
  .orElseThrow(() -> new EntityNotFoundException("Cliente no encontrado con ID: " + clienteId));
  CuentaPuntos cuenta = cuentaPuntosRepository.findByCliente(cliente)
  .orElse(null);
  int saldoPuntos = (cuenta != null) ? cuenta.getSaldoPuntos() : 0;
  List<CuponDTO> cuponesDto = cuponesVigentes.stream()
  .map(cuponMapper::toCuponDTO)
  .toList();
  Optional<ReglaPuntos> reglaOpt = reglaPuntosService.getReglaActiva();
  if (reglaOpt.isPresent() && saldoPuntos > 0) {
  ReglaPuntos regla = reglaOpt.get();
  if (regla.getEquivalenciaPuntos() != null && regla.getEquivalenciaPuntos().compareTo(BigDecimal.ZERO) > 0) {
  BigDecimal valor = regla.getEquivalenciaPuntos().multiply(new BigDecimal(saldoPuntos));
  valor = valor.setScale(2, RoundingMode.HALF_UP);
  equivalencia = String.format("$%,.0f", valor);
  List<Recompensa> recompensasCandidatas = recompensaRepository.findAll();
  List<RecompensaDTO> recompensasAlcanzables = recompensasCandidatas.stream()
  .filter(r -> Boolean.TRUE.equals(r.getActivo()) && r.getStock() > 0)
  .filter(r -> saldoPuntos >= r.getPuntosRequeridos())
  .map(recompensaMapper::toDto)
  .collect(Collectors.toList());
  ClienteFidelidadDTO dto = new ClienteFidelidadDTO();
  dto.setClienteId(cliente.getId());
  dto.setNombreCompleto(cliente.getNombre() + " " + cliente.getApellido());
  dto.setPuntosAcumulados(saldoPuntos);
  dto.setEquivalenciaMonetaria(equivalencia);
  dto.setCuponesDisponibles(cuponesDto);
  dto.setRecompensasAlcanzables(recompensasAlcanzables);
}
class DashboardService {
  private VentaRepository ventaRepository
  private ProductoRepository productoRepository
  private UsuarioRepository usuarioRepository
  private PedidoRepository pedidoRepository
  return item
  return dto
  public DashboardStatsDTO getEstadisticas() {
  LocalDateTime inicioMes = LocalDate.now().withDayOfMonth(1).atStartOfDay();
  LocalDateTime finMes = LocalDate.now().plusMonths(1).withDayOfMonth(1).atStartOfDay().minusNanos(1);
  return getStats(inicioMes, finMes);
  public DashboardStatsDTO getEstadisticasFiltradas(LocalDate inicio, LocalDate fin) {
  LocalDateTime fechaInicio = (inicio != null) ? inicio.atStartOfDay() : LocalDate.now().withDayOfMonth(1).atStartOfDay();
  LocalDateTime fechaFin = (fin != null) ? fin.atTime(LocalTime.MAX) : LocalDate.now().atTime(LocalTime.MAX);
  return getStats(fechaInicio, fechaFin);
  private DashboardStatsDTO getStats(LocalDateTime inicio, LocalDateTime fin) {
  BigDecimal totalVentasRango = ventaRepository.findTotalVentasEntreFechas(inicio, fin)
  .orElse(BigDecimal.ZERO);
  long cantidadVentas = ventaRepository.countVentasEntreFechas(inicio, fin);
  LocalDateTime inicioHoy = LocalDate.now().atStartOfDay();
  LocalDateTime finHoy = LocalDate.now().atTime(LocalTime.MAX);
  BigDecimal totalVentasHoy = ventaRepository.findTotalVentasEntreFechas(inicioHoy, finHoy)
  .orElse(BigDecimal.ZERO);
  long productosBajoStock = productoRepository.countProductosBajoStock();
  long clientesActivos = usuarioRepository.countClientesActivos();
  DashboardStatsDTO dto = new DashboardStatsDTO();
  dto.setTotalVentasMes(totalVentasRango);
  dto.setCantidadVentasPeriodo(cantidadVentas);
  dto.setProductosBajoStock(productosBajoStock);
  dto.setClientesActivos(clientesActivos);
  dto.setTotalVentasHoy(totalVentasHoy);
  .findByEstado(EstadoPedido.EN_CAMINO)
  .stream()
  .map(p -> {
  DashboardStatsDTO.PedidoEnCaminoDTO item = new DashboardStatsDTO.PedidoEnCaminoDTO();
  if (p.getProveedor() != null) {
  item.setProveedor(p.getProveedor().getRazonSocial());
  item.setProveedor("Proveedor Desconocido");
  item.setFechaEntrega(p.getFechaEntregaEstimada());
  if (p.getFechaEntregaEstimada() != null) {
  long dias = ChronoUnit.DAYS.between(LocalDate.now(), p.getFechaEntregaEstimada());
  item.setDiasRestantes(dias);
  item.setDiasRestantes(0L);
  .sorted((p1, p2) -> {
  if(p1.getFechaEntrega() == null) return 1;
  if(p2.getFechaEntrega() == null) return -1;
  return p1.getFechaEntrega().compareTo(p2.getFechaEntrega());
  .limit(5)
  .collect(Collectors.toList());
  dto.setPedidosEnCamino(enCamino);
  public List<VentasPorDiaDTO> getVentasPorRango(LocalDate inicio, LocalDate fin) {
  LocalDateTime fechaInicio = (inicio != null) ? inicio.atStartOfDay() : LocalDate.now().minusDays(7).atStartOfDay();
  LocalDateTime fechaFin = (fin != null) ? fin.atTime(LocalTime.MAX) : LocalDate.now().atTime(LocalTime.MAX);
  return ventaRepository.findVentasSumarizadasPorDia(fechaInicio, fechaFin);
  public List<TopProductoDTO> getTopProductosPorRango(LocalDate inicio, LocalDate fin) {
  LocalDateTime fechaInicio = (inicio != null) ? inicio.atStartOfDay() : LocalDate.now().withDayOfMonth(1).atStartOfDay();
  LocalDateTime fechaFin = (fin != null) ? fin.atTime(LocalTime.MAX) : LocalDate.now().atTime(LocalTime.MAX);
  return ventaRepository.findTop5ProductosVendidos(fechaInicio, fechaFin);
  public List<VentasPorCategoriaDTO> getVentasPorCategoria(LocalDate inicio, LocalDate fin) {
  LocalDateTime fechaInicio = (inicio != null) ? inicio.atStartOfDay() : LocalDate.now().withDayOfMonth(1).atStartOfDay();
  LocalDateTime fechaFin = (fin != null) ? fin.atTime(LocalTime.MAX) : LocalDate.now().atTime(LocalTime.MAX);
  return ventaRepository.findVentasPorCategoria(fechaInicio, fechaFin);
  public List<VentasPorDiaDTO> getVentasUltimos7Dias() {
  return getVentasPorRango(LocalDate.now().minusDays(7), LocalDate.now());
  public List<TopProductoDTO> getTop5ProductosDelMes() {
  return getTopProductosPorRango(LocalDate.now().withDayOfMonth(1), LocalDate.now());
}
class AuditoriaService {
  private AuditoriaRepository auditoriaRepository
  private AuditoriaSpecification auditoriaSpecification
  public void guardar(Auditoria log) {
  auditoriaRepository.save(log);
  public Page<Auditoria> getLogs(Pageable pageable) {
  return auditoriaRepository.findAllByOrderByFechaDesc(pageable);
  public Page<Auditoria> filtrarAuditoria(AuditoriaFiltroDTO filtro, Pageable pageable) {
  Specification<Auditoria> spec = auditoriaSpecification.getByFilters(filtro);
  return auditoriaRepository.findAll(spec, pageable);
}
class VentaEventListener {
  return
  )
  public void handleVentaRealizada(VentaRealizadaEvent event) {
  logger.info("-> 📨 [EVENTO] Procesando venta #{} para envío de email...", event.getVentaId());
  Venta venta = ventaRepository.findByIdWithDetails(event.getVentaId())
  .orElseThrow(() -> new RuntimeException("Venta no encontrada ID: " + event.getVentaId()));
  byte[] pdf = pdfService.generarComprobanteVenta(venta);
  if (pdf == null || pdf.length == 0) {
  logger.error("❌ Error: PDF generado vacío para Venta #{}", venta.getId());
  Context context = new Context();
  context.setVariable("clienteNombre", venta.getCliente().getNombre());
  BigDecimal total = venta.getTotalVenta() != null ? venta.getTotalVenta() : BigDecimal.ZERO;
  context.setVariable("totalVenta", String.format("$%.2f", total));
  context.setVariable("idVenta", venta.getId());
  context.setVariable("fechaVenta", venta.getFechaVenta());
  BigDecimal descuento = venta.getMontoDescuento() != null ? venta.getMontoDescuento() : BigDecimal.ZERO;
  context.setVariable("montoDescuento", String.format("$%.2f", descuento));
  context.setVariable("hayDescuento", descuento.compareTo(BigDecimal.ZERO) > 0);
  if (venta.getCupon() != null) {
  context.setVariable("codigoCupon", venta.getCupon().getCodigo());
  context.setVariable("codigoCupon", "");
  String html = templateEngine.process("email-comprobante", context);
  logger.info("✅ Email con comprobante enviado a {}", venta.getCliente().getEmail());
  } catch (Exception e) {
  logger.error("🔴 Error crítico enviando email de venta #{}: {}", event.getVentaId(), e.getMessage(), e);
}
class ProcesoAutomaticoService {
  private final ProductoRepository productoRepository
  private final CotizacionRepository cotizacionRepository
  private final ProveedorRepository proveedorRepository
  private final ListaEsperaRepository listaEsperaRepository
  private final EmailService emailService
  private final TemplateEngine templateEngine
  private final ItemCotizacionRepository itemCotizacionRepository
  private final WhatsappService whatsappService
  private final PedidoRepository pedidoRepository
  private final MovimientoPuntosRepository movimientoRepository
  private final CuentaPuntosRepository cuentaRepository
  )
  return nuevasCotizaciones
  String emailAdmin
  int procesados
  procesados++
  public void generarPrePedidosAgrupados() {
  logger.info("⏰ [AUTO] Iniciando ciclo de reabastecimiento...");
  List<Cotizacion> cotizacionesParaNotificar = crearCotizacionesEnTransaccion();
  if (!cotizacionesParaNotificar.isEmpty()) {
  logger.info("📨 Iniciando envío de {} solicitudes agrupadas...", cotizacionesParaNotificar.size());
  for (Cotizacion cotizacion : cotizacionesParaNotificar) {
  notificarProveedor(cotizacion);
  logger.info("✅ Todo el stock está en orden o ya fue solicitado.");
  protected List<Cotizacion> crearCotizacionesEnTransaccion() {
  List<Producto> productosFaltantes = productoRepository.findProductosConStockBajo();
  if (productosFaltantes.isEmpty()) return Collections.emptyList();
  List<Proveedor> proveedoresActivos = proveedorRepository.findByEstado(EstadoUsuario.ACTIVO);
  if (proveedoresActivos.isEmpty()) {
  logger.warn("⚠️ No hay proveedores activos para reponer stock.");
  return Collections.emptyList();
  List<Cotizacion> nuevasCotizaciones = new ArrayList<>();
  for (Proveedor proveedor : proveedoresActivos) {
  List<Producto> productosParaEsteProveedor = new ArrayList<>();
  for (Producto p : productosFaltantes) {
  if (proveedorVendeCategoria(proveedor, p.getCategoria())) {
  Arrays.asList(EstadoCotizacion.PENDIENTE_PROVEEDOR, EstadoCotizacion.RECIBIDA, EstadoCotizacion.CONFIRMADA_ADMIN)
  if (!yaPedido) {
  productosParaEsteProveedor.add(p);
  if (!productosParaEsteProveedor.isEmpty()) {
  Cotizacion nueva = guardarCotizacion(proveedor, productosParaEsteProveedor);
  nuevasCotizaciones.add(nueva);
  nueva.getId(), proveedor.getRazonSocial(), productosParaEsteProveedor.size());
  private Cotizacion guardarCotizacion(Proveedor proveedor, List<Producto> productos) {
  Cotizacion cotizacion = new Cotizacion();
  cotizacion.setProveedor(proveedor);
  cotizacion.setEstado(EstadoCotizacion.PENDIENTE_PROVEEDOR);
  cotizacion.setToken(UUID.randomUUID().toString());
  cotizacion.setFechaCreacion(LocalDateTime.now());
  Set<ItemCotizacion> items = new HashSet<>();
  for (Producto producto : productos) {
  ItemCotizacion item = new ItemCotizacion();
  item.setCotizacion(cotizacion);
  item.setProducto(producto);
  int cant = (producto.getLoteReposicion() > 0)
  ? producto.getLoteReposicion()
  : Math.max(1, producto.getStockMinimo() * 2);
  item.setCantidadSolicitada(cant);
  item.setEstado(EstadoItemCotizacion.PENDIENTE);
  items.add(item);
  cotizacion.setItems(items);
  return cotizacionRepository.save(cotizacion);
  private void notificarProveedor(Cotizacion cotizacion) {
  Proveedor proveedor = cotizacion.getProveedor();
  if (proveedor.getEmail() == null || proveedor.getEmail().isBlank()) return;
  Context context = new Context();
  context.setVariable("proveedorNombre", proveedor.getRazonSocial());
  context.setVariable("linkOferta", linkOferta);
  context.setVariable("items", cotizacion.getItems());
  String html = templateEngine.process("email-oferta", context);
  "Masterserv: Solicitud Cotización #" + cotizacion.getId(), html);
  logger.info("-> 📨 Email enviado exitosamente a {}", proveedor.getRazonSocial());
  } catch (Exception e) {
  logger.error("-> 🔴 Error enviando email a {}: {}", proveedor.getRazonSocial(), e.getMessage());
  public void verificarPedidosEnCamino() {
  logger.info("📅 [ALERTA DIARIA] Verificando arribos de mercadería...");
  LocalDate hoy = LocalDate.now();
  LocalDate manana = hoy.plusDays(1);
  List<Pedido> lleganHoy = pedidoRepository.findByEstadoAndFechaEntregaEstimada(EstadoPedido.EN_CAMINO, hoy);
  if (!lleganHoy.isEmpty()) {
  notificarAdminArribo(lleganHoy, "¡Llegan HOY!", "Prepara el depósito, hoy recibimos mercadería de:");
  List<Pedido> lleganManana = pedidoRepository.findByEstadoAndFechaEntregaEstimada(EstadoPedido.EN_CAMINO, manana);
  if (!lleganManana.isEmpty()) {
  notificarAdminArribo(lleganManana, "Llegan Mañana", "Te aviso que para mañana esperamos pedidos de:");
  if (lleganHoy.isEmpty() && lleganManana.isEmpty()) {
  logger.info("-> 😴 Nada programado para hoy ni mañana.");
  private void notificarAdminArribo(List<Pedido> pedidos, String titulo, String mensajeIntro) {
  StringBuilder cuerpo = new StringBuilder();
  cuerpo.append("<h2 style='color: #E41E26;'>").append(titulo).append("</h2>");
  cuerpo.append("<p>").append(mensajeIntro).append("</p><ul>");
  for (Pedido p : pedidos) {
  cuerpo.append("<li><strong>")
  .append(p.getProveedor().getRazonSocial())
  .append("</strong> (Orden #").append(p.getId()).append(")")
  .append("</li>");
  cuerpo.append("</ul>");
  cuerpo.append("<p>Ingresa al sistema para recepcionar la mercadería.</p>");
  emailService.enviarEmailHtml(emailAdmin, "📦 Alerta Stock: " + titulo, cuerpo.toString());
  } catch (Exception e) {
  logger.error("Error notificando admin: {}", e.getMessage());
  public void handleStockActualizado(StockActualizadoEvent event) {
  if (event.stockNuevo() <= 0) return;
  procesarListaEspera(event.productoId());
  public void procesarListaEspera(Long productoId) {
  Producto producto = productoRepository.findById(productoId).orElse(null);
  if (producto == null) return;
  List<ListaEspera> esperas = listaEsperaRepository.findByProductoAndEstado(producto, EstadoListaEspera.PENDIENTE);
  if (esperas.isEmpty()) return;
  logger.info("-> 📣 Notificando a {} clientes en espera por '{}'...", esperas.size(), producto.getNombre());
  for (ListaEspera espera : esperas) {
  Usuario usuario = espera.getUsuario();
  "Hola " + usuario.getNombre() + ", tu producto ya está disponible.");
  if (whatsappService != null && usuario.getTelefono() != null) {
  "👋 Hola " + usuario.getNombre() + ", buenas noticias: Llegó " + producto.getNombre());
  espera.setEstado(EstadoListaEspera.NOTIFICADA);
  } catch (Exception e) {
  logger.error("Error notificando usuario {}: {}", espera.getUsuario().getEmail(), e.getMessage());
  listaEsperaRepository.saveAll(esperas);
  public void procesarVencimientoPuntos() {
  logger.info("⏳ [AUTO] Iniciando verificación de puntos vencidos...");
  LocalDateTime ahora = LocalDateTime.now();
  .findByFechaCaducidadPuntosBeforeAndTipoMovimiento(ahora, TipoMovimientoPuntos.GANADO);
  for (MovimientoPuntos movOriginal : candidatosVencidos) {
  boolean yaExpirado = movimientoRepository.existsByVentaAndTipoMovimiento(movOriginal.getVenta(), TipoMovimientoPuntos.EXPIRADO);
  boolean yaRevertido = movimientoRepository.existsByVentaAndTipoMovimiento(movOriginal.getVenta(), TipoMovimientoPuntos.REVERSION);
  if (!yaExpirado && !yaRevertido) {
  CuentaPuntos cuenta = movOriginal.getCuentaPuntos();
  int puntosAVencer = movOriginal.getPuntos();
  if (cuenta.getSaldoPuntos() > 0) {
  int puntosRealesAQuitar = Math.min(cuenta.getSaldoPuntos(), puntosAVencer);
  if (puntosRealesAQuitar > 0) {
  MovimientoPuntos expiracion = new MovimientoPuntos();
  expiracion.setCuentaPuntos(cuenta);
  expiracion.setVenta(movOriginal.getVenta());
  expiracion.setPuntos(-puntosRealesAQuitar);
  expiracion.setTipoMovimiento(TipoMovimientoPuntos.EXPIRADO);
  expiracion.setDescripcion("Vencimiento de puntos (Origen: Venta #" + movOriginal.getVenta().getId() + ")");
  cuenta.setSaldoPuntos(cuenta.getSaldoPuntos() - puntosRealesAQuitar);
  movimientoRepository.save(expiracion);
  cuentaRepository.save(cuenta);
  if (procesados > 0) {
  logger.info("✅ [AUTO] Puntos expirados en {} ventas antiguas.", procesados);
  logger.info("ℹ️ [AUTO] No hubo puntos para expirar hoy.");
  private boolean proveedorVendeCategoria(Proveedor proveedor, Categoria categoria) {
  if (proveedor.getCategorias() == null || proveedor.getCategorias().isEmpty()) return true;
  return proveedor.getCategorias().stream()
  .anyMatch(c -> c.getId().equals(categoria.getId()));
}
class ClienteService {
  private UsuarioRepository usuarioRepository
  private TipoDocumentoRepository tipoDocumentoRepository
  private RolRepository rolRepository
  private ClienteMapper clienteMapper
  private PasswordEncoder passwordEncoder
  private EmailService emailService
  String passTemporal
  return usuarioGuardado
  String asunto
  )
  public ClientePerfilDTO getPerfilByEmail(String email) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Cliente no encontrado: " + email));
  return clienteMapper.toClientePerfilDTO(usuario);
  public ClientePerfilDTO updatePerfilByEmail(String email, ClientePerfilUpdateDTO updateDTO) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Cliente no encontrado: " + email));
  TipoDocumento tipoDoc = tipoDocumentoRepository.findById(updateDTO.getTipoDocumentoId())
  .orElseThrow(() -> new RuntimeException("Tipo de Documento no válido: ID " + updateDTO.getTipoDocumentoId()));
  Optional<Usuario> userConMismoDoc = usuarioRepository.findByDocumento(updateDTO.getDocumento());
  if (userConMismoDoc.isPresent() && !userConMismoDoc.get().getId().equals(usuario.getId())) {
  throw new RuntimeException("El número de documento ya está registrado por otro usuario.");
  clienteMapper.updateUsuarioFromDTO(updateDTO, usuario);
  usuario.setTipoDocumento(tipoDoc);
  Usuario usuarioActualizado = usuarioRepository.save(usuario);
  return clienteMapper.toClientePerfilDTO(usuarioActualizado);
  public void cambiarPassword(String email, CambioPasswordDTO dto) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
  if (!passwordEncoder.matches(dto.getPasswordActual(), usuario.getPasswordHash())) {
  throw new RuntimeException("La contraseña actual es incorrecta.");
  usuario.setPasswordHash(passwordEncoder.encode(dto.getPasswordNueva()));
  usuario.setDebeCambiarPassword(false);
  usuarioRepository.save(usuario);
  public Usuario registrarClienteDesdePos(ClienteDTO dto) {
  if (usuarioRepository.existsByEmail(dto.getEmail())) {
  throw new RuntimeException("El email ya está registrado.");
  if (dto.getDocumento() != null && !dto.getDocumento().isEmpty()) {
  if (usuarioRepository.findByDocumento(dto.getDocumento()).isPresent()) {
  throw new RuntimeException("El documento ya está registrado.");
  Usuario usuario = new Usuario();
  usuario.setNombre(dto.getNombre());
  usuario.setApellido(dto.getApellido());
  usuario.setEmail(dto.getEmail());
  usuario.setDocumento(dto.getDocumento());
  usuario.setTelefono(dto.getTelefono());
  usuario.setEstado(EstadoUsuario.ACTIVO);
  if (dto.getTipoDocumentoId() != null) {
  TipoDocumento td = tipoDocumentoRepository.findById(dto.getTipoDocumentoId()).orElse(null);
  usuario.setTipoDocumento(td);
  else if (dto.getTipoDocumentoBusqueda() != null) {
  TipoDocumento td = tipoDocumentoRepository.findByNombreCorto(dto.getTipoDocumentoBusqueda())
  .orElse(null);
  usuario.setTipoDocumento(td);
  Rol rolCliente = rolRepository.findByNombreRol("ROLE_CLIENTE")
  .orElseThrow(() -> new RuntimeException("Error crítico: Rol ROLE_CLIENTE no existe en BD"));
  usuario.setRoles(Set.of(rolCliente));
  usuario.setPasswordHash(passwordEncoder.encode(passTemporal));
  usuario.setDebeCambiarPassword(true);
  Usuario usuarioGuardado = usuarioRepository.save(usuario);
  enviarEmailBienvenida(usuario.getEmail(), usuario.getNombre(), passTemporal);
  } catch (Exception e) {
  System.err.println("Error enviando email: " + e.getMessage());
  private void enviarEmailBienvenida(String email, String nombre, String pass) {
  emailService.enviarEmail(email, asunto, cuerpo);
}
class PdfService {
  private DashboardService dashboardService
  )
  BigDecimal totalCalculado
  )
  )
  BigDecimal subtotalSinDescuento
  )
  BigDecimal ticketPromedio
  return cell
  private static final Font FONT_TITULO = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 18, Color.BLACK);
  private static final Font FONT_SUBTITULO = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 12, Color.DARK_GRAY);
  private static final Font FONT_BOLD = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 10, Color.BLACK);
  private static final Font FONT_NORMAL = FontFactory.getFont(FontFactory.HELVETICA, 10, Color.BLACK);
  private static final Font FONT_DATA_EMPRESA = FontFactory.getFont(FontFactory.HELVETICA, 9, Color.GRAY);
  private static final Font FONT_HEADER_TABLA = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 10, Color.WHITE);
  private static final Font FONT_LEYENDA = FontFactory.getFont(FontFactory.HELVETICA_OBLIQUE, 9, Color.DARK_GRAY);
  private String formatearMoneda(BigDecimal valor) {
  if (valor == null) valor = BigDecimal.ZERO;
  DecimalFormatSymbols simbolos = new DecimalFormatSymbols();
  simbolos.setGroupingSeparator('.');
  simbolos.setDecimalSeparator(',');
  DecimalFormat df = new DecimalFormat("#,##0.00", simbolos);
  return "$ " + df.format(valor);
  public byte[] generarComprobantePedido(Pedido pedido) {
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  Document document = new Document(PageSize.A4);
  PdfWriter.getInstance(document, baos);
  document.open();
  Paragraph titulo = new Paragraph("MASTERSERV360", FONT_TITULO);
  titulo.setAlignment(Element.ALIGN_CENTER);
  document.add(titulo);
  Paragraph subtitulo = new Paragraph("Orden de Compra (Interno)", FONT_SUBTITULO);
  subtitulo.setAlignment(Element.ALIGN_CENTER);
  document.add(subtitulo);
  datosEmpresa.setAlignment(Element.ALIGN_CENTER);
  datosEmpresa.setSpacingAfter(10);
  document.add(datosEmpresa);
  document.add(new LineSeparator());
  Paragraph infoPedido = new Paragraph();
  infoPedido.setSpacingBefore(10);
  infoPedido.setSpacingAfter(10);
  infoPedido.add(new Chunk("Nº Pedido: " + pedido.getId() + "\n", FONT_BOLD));
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
  infoPedido.add(new Chunk("Fecha Emisión: " + pedido.getFechaPedido().format(formatter) + "\n", FONT_NORMAL));
  infoPedido.add(new Chunk("Estado: " + pedido.getEstado() + "\n\n", FONT_NORMAL));
  if (pedido.getProveedor() != null) {
  infoPedido.add(new Chunk("PROVEEDOR:\n", FONT_BOLD));
  infoPedido.add(new Chunk("Razón Social: " + pedido.getProveedor().getRazonSocial() + "\n", FONT_NORMAL));
  infoPedido.add(new Chunk("CUIT: " + pedido.getProveedor().getCuit() + "\n", FONT_NORMAL));
  document.add(infoPedido);
  PdfPTable table = new PdfPTable(4);
  table.setWidthPercentage(100);
  table.setWidths(new float[] { 4f, 1f, 2f, 2f });
  table.setSpacingBefore(10f);
  table.addCell(crearCeldaHeader("Producto"));
  table.addCell(crearCeldaHeader("Cant."));
  table.addCell(crearCeldaHeader("Costo Unit."));
  table.addCell(crearCeldaHeader("Subtotal"));
  for (DetallePedido detalle : pedido.getDetalles()) {
  table.addCell(new Paragraph(detalle.getProducto().getNombre(), FONT_NORMAL));
  PdfPCell cellCant = new PdfPCell(new Paragraph(String.valueOf(detalle.getCantidad()), FONT_NORMAL));
  cellCant.setHorizontalAlignment(Element.ALIGN_CENTER);
  table.addCell(cellCant);
  BigDecimal precio = (detalle.getPrecioUnitario() != null) ? detalle.getPrecioUnitario() : BigDecimal.ZERO;
  PdfPCell cellPrecio = new PdfPCell(new Paragraph(formatearMoneda(precio), FONT_NORMAL));
  cellPrecio.setHorizontalAlignment(Element.ALIGN_RIGHT);
  table.addCell(cellPrecio);
  BigDecimal subtotalItem = precio.multiply(new BigDecimal(detalle.getCantidad()));
  totalCalculado = totalCalculado.add(subtotalItem);
  PdfPCell cellSub = new PdfPCell(new Paragraph(formatearMoneda(subtotalItem), FONT_NORMAL));
  cellSub.setHorizontalAlignment(Element.ALIGN_RIGHT);
  table.addCell(cellSub);
  document.add(table);
  Paragraph totales = new Paragraph();
  totales.setAlignment(Element.ALIGN_RIGHT);
  totales.setSpacingBefore(15);
  Font fontTotal = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 14, Color.BLACK);
  BigDecimal totalFinal = (pedido.getTotalPedido() != null) ? pedido.getTotalPedido() : totalCalculado;
  totales.add(new Chunk("TOTAL: " + formatearMoneda(totalFinal), fontTotal));
  document.add(totales);
  } catch (DocumentException e) {
  throw new RuntimeException("Error al generar el comprobante de pedido PDF", e);
  document.close();
  return baos.toByteArray();
  public byte[] generarOrdenCompraProveedor(Pedido pedido) {
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  Document document = new Document(PageSize.A4);
  PdfWriter.getInstance(document, baos);
  document.open();
  Paragraph titulo = new Paragraph("MASTERSERV360", FONT_TITULO);
  titulo.setAlignment(Element.ALIGN_CENTER);
  document.add(titulo);
  Paragraph subtitulo = new Paragraph("Orden de Compra / Solicitud de Mercadería", FONT_SUBTITULO);
  subtitulo.setAlignment(Element.ALIGN_CENTER);
  document.add(subtitulo);
  datosEmpresa.setAlignment(Element.ALIGN_CENTER);
  datosEmpresa.setSpacingAfter(10);
  document.add(datosEmpresa);
  document.add(new LineSeparator());
  Paragraph infoPedido = new Paragraph();
  infoPedido.setSpacingBefore(10);
  infoPedido.setSpacingAfter(10);
  infoPedido.add(new Chunk("Orden de Compra Nº: " + pedido.getId() + "\n", FONT_BOLD));
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
  infoPedido.add(new Chunk("Fecha Emisión: " + pedido.getFechaPedido().format(formatter) + "\n\n", FONT_NORMAL));
  if (pedido.getProveedor() != null) {
  infoPedido.add(new Chunk("SEÑORES PROVEEDORES:\n", FONT_BOLD));
  infoPedido.add(new Chunk("Razón Social: " + pedido.getProveedor().getRazonSocial() + "\n", FONT_NORMAL));
  infoPedido.add(new Chunk("CUIT: " + pedido.getProveedor().getCuit() + "\n", FONT_NORMAL));
  document.add(infoPedido);
  PdfPTable table = new PdfPTable(2);
  table.setWidthPercentage(100);
  table.setWidths(new float[] { 4f, 1f });
  table.setSpacingBefore(10f);
  table.addCell(crearCeldaHeader("Descripción del Producto"));
  table.addCell(crearCeldaHeader("Cantidad"));
  for (DetallePedido detalle : pedido.getDetalles()) {
  PdfPCell cellProd = new PdfPCell(new Paragraph(detalle.getProducto().getNombre(), FONT_NORMAL));
  cellProd.setPadding(5);
  table.addCell(cellProd);
  PdfPCell cellCant = new PdfPCell(new Paragraph(String.valueOf(detalle.getCantidad()), FONT_NORMAL));
  cellCant.setHorizontalAlignment(Element.ALIGN_CENTER);
  cellCant.setPadding(5);
  table.addCell(cellCant);
  document.add(table);
  Paragraph pie = new Paragraph("\nNota: Por favor confirmar recepción, disponibilidad y fecha estimada de entrega.", FONT_DATA_EMPRESA);
  pie.setAlignment(Element.ALIGN_CENTER);
  document.add(pie);
  } catch (DocumentException e) {
  throw new RuntimeException("Error al generar la Orden de Compra PDF para proveedor", e);
  document.close();
  return baos.toByteArray();
  public byte[] generarComprobanteVenta(Venta venta) {
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  Document document = new Document(PageSize.A4);
  PdfWriter.getInstance(document, baos);
  document.open();
  Paragraph titulo = new Paragraph("MASTERSERV360", FONT_TITULO);
  titulo.setAlignment(Element.ALIGN_CENTER);
  document.add(titulo);
  Paragraph subtitulo = new Paragraph("Comprobante de Venta (No Fiscal)", FONT_SUBTITULO);
  subtitulo.setAlignment(Element.ALIGN_CENTER);
  document.add(subtitulo);
  datosEmpresa.setAlignment(Element.ALIGN_CENTER);
  datosEmpresa.setSpacingAfter(10);
  document.add(datosEmpresa);
  document.add(new LineSeparator());
  Paragraph infoVenta = new Paragraph();
  infoVenta.setSpacingBefore(10);
  infoVenta.setSpacingAfter(10);
  infoVenta.add(new Chunk("Nº Venta: " + venta.getId() + "\n", FONT_BOLD));
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
  infoVenta.add(new Chunk("Fecha: " + venta.getFechaVenta().format(formatter) + "\n", FONT_NORMAL));
  if (venta.getCliente() != null) {
  infoVenta.add(new Chunk("Cliente: " + venta.getCliente().getNombre() + " " + venta.getCliente().getApellido() + "\n", FONT_NORMAL));
  if(venta.getCliente().getDocumento() != null) {
  infoVenta.add(new Chunk("DNI/CUIT: " + venta.getCliente().getDocumento() + "\n", FONT_NORMAL));
  document.add(infoVenta);
  PdfPTable table = new PdfPTable(4);
  table.setWidthPercentage(100);
  table.setWidths(new float[] { 4f, 1f, 2f, 2f });
  table.setSpacingBefore(10f);
  table.addCell(crearCeldaHeader("Producto"));
  table.addCell(crearCeldaHeader("Cant."));
  table.addCell(crearCeldaHeader("Precio Unit."));
  table.addCell(crearCeldaHeader("Subtotal"));
  for (DetalleVenta detalle : venta.getDetalles()) {
  table.addCell(new Paragraph(detalle.getProducto().getNombre(), FONT_NORMAL));
  PdfPCell cellCant = new PdfPCell(new Paragraph(String.valueOf(detalle.getCantidad()), FONT_NORMAL));
  cellCant.setHorizontalAlignment(Element.ALIGN_CENTER);
  table.addCell(cellCant);
  PdfPCell cellPrecio = new PdfPCell(new Paragraph(formatearMoneda(detalle.getPrecioUnitario()), FONT_NORMAL));
  cellPrecio.setHorizontalAlignment(Element.ALIGN_RIGHT);
  table.addCell(cellPrecio);
  BigDecimal subtotalItem = detalle.getPrecioUnitario().multiply(new BigDecimal(detalle.getCantidad()));
  subtotalSinDescuento = subtotalSinDescuento.add(subtotalItem);
  PdfPCell cellSub = new PdfPCell(new Paragraph(formatearMoneda(subtotalItem), FONT_NORMAL));
  cellSub.setHorizontalAlignment(Element.ALIGN_RIGHT);
  table.addCell(cellSub);
  document.add(table);
  Paragraph totales = new Paragraph();
  totales.setAlignment(Element.ALIGN_RIGHT);
  totales.setSpacingBefore(15);
  BigDecimal descuento = subtotalSinDescuento.subtract(venta.getTotalVenta());
  if (descuento.compareTo(BigDecimal.ZERO) > 0) {
  totales.add(new Chunk("Subtotal: " + formatearMoneda(subtotalSinDescuento) + "\n", FONT_NORMAL));
  Font fontRojo = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 10, Color.RED);
  totales.add(new Chunk("Descuento: -" + formatearMoneda(descuento) + "\n", fontRojo));
  Font fontTotal = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 16, Color.BLACK);
  totales.add(new Chunk("TOTAL: " + formatearMoneda(venta.getTotalVenta()), fontTotal));
  document.add(totales);
  } catch (DocumentException e) {
  throw new RuntimeException("Error al generar el comprobante PDF", e);
  document.close();
  return baos.toByteArray();
  public byte[] generarReporteDashboard(DashboardFilterDTO filtro) {
  ByteArrayOutputStream baos = new ByteArrayOutputStream();
  Document document = new Document(PageSize.A4);
  PdfWriter.getInstance(document, baos);
  document.open();
  Paragraph titulo = new Paragraph("Reporte de Gestión - Masterserv360", FONT_TITULO);
  titulo.setAlignment(Element.ALIGN_CENTER);
  document.add(titulo);
  DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy");
  String inicioStr = (filtro.getFechaInicio() != null) ? filtro.getFechaInicio().format(fmt) : "Inicio";
  String finStr = (filtro.getFechaFin() != null) ? filtro.getFechaFin().format(fmt) : "Hoy";
  Paragraph contexto = new Paragraph();
  contexto.setAlignment(Element.ALIGN_CENTER);
  contexto.setSpacingAfter(20);
  contexto.add(new Chunk("Periodo: " + inicioStr + " al " + finStr + "\n", FONT_SUBTITULO));
  if (filtro.getGeneradoPor() != null) {
  contexto.add(new Chunk("Generado por: " + filtro.getGeneradoPor(), FONT_DATA_EMPRESA));
  document.add(contexto);
  if (filtro.getGraficoBase64() != null && !filtro.getGraficoBase64().isEmpty()) {
  String base64Image = filtro.getGraficoBase64().split(",")[1];
  byte[] imageBytes = Base64.getDecoder().decode(base64Image);
  Image grafico = Image.getInstance(imageBytes);
  grafico.setAlignment(Element.ALIGN_CENTER);
  grafico.scaleToFit(500, 250);
  grafico.setSpacingAfter(5);
  document.add(grafico);
  leyenda.setAlignment(Element.ALIGN_CENTER);
  leyenda.setSpacingAfter(20);
  document.add(leyenda);
  } catch (Exception e) {
  System.err.println("Error al procesar imagen del gráfico: " + e.getMessage());
  DashboardStatsDTO stats = dashboardService.getEstadisticasFiltradas(filtro.getFechaInicio(), filtro.getFechaFin());
  List<TopProductoDTO> top = dashboardService.getTopProductosPorRango(filtro.getFechaInicio(), filtro.getFechaFin());
  PdfPTable tableMetrics = new PdfPTable(3);
  tableMetrics.setWidthPercentage(100);
  tableMetrics.setSpacingAfter(20);
  tableMetrics.addCell(crearCeldaHeader("Ventas Totales"));
  tableMetrics.addCell(crearCeldaHeader("Cant. Transacciones"));
  tableMetrics.addCell(crearCeldaHeader("Ticket Promedio"));
  PdfPCell cellVentas = new PdfPCell(new Paragraph(formatearMoneda(stats.getTotalVentasMes()), FONT_NORMAL));
  cellVentas.setHorizontalAlignment(Element.ALIGN_CENTER);
  cellVentas.setPadding(8);
  tableMetrics.addCell(cellVentas);
  PdfPCell cellCant = new PdfPCell(new Paragraph(String.valueOf(stats.getCantidadVentasPeriodo()), FONT_NORMAL));
  cellCant.setHorizontalAlignment(Element.ALIGN_CENTER);
  cellCant.setPadding(8);
  tableMetrics.addCell(cellCant);
  if (stats.getCantidadVentasPeriodo() > 0) {
  ticketPromedio = stats.getTotalVentasMes()
  .divide(BigDecimal.valueOf(stats.getCantidadVentasPeriodo()), 2, RoundingMode.HALF_UP);
  PdfPCell cellTicket = new PdfPCell(new Paragraph(formatearMoneda(ticketPromedio), FONT_NORMAL));
  cellTicket.setHorizontalAlignment(Element.ALIGN_CENTER);
  cellTicket.setPadding(8);
  tableMetrics.addCell(cellTicket);
  document.add(tableMetrics);
  Paragraph subtituloTop = new Paragraph("Top Productos Vendidos", FONT_SUBTITULO);
  subtituloTop.setSpacingAfter(10);
  document.add(subtituloTop);
  PdfPTable tableTop = new PdfPTable(2);
  tableTop.setWidthPercentage(100);
  tableTop.setWidths(new float[] { 3f, 1f });
  tableTop.addCell(crearCeldaHeader("Producto"));
  tableTop.addCell(crearCeldaHeader("Cantidad Vendida"));
  for (TopProductoDTO p : top) {
  PdfPCell cellNombre = new PdfPCell(new Paragraph(p.getNombre(), FONT_NORMAL));
  cellNombre.setPadding(5);
  tableTop.addCell(cellNombre);
  PdfPCell cellCantProd = new PdfPCell(new Paragraph(String.valueOf(p.getCantidadVendida()), FONT_NORMAL));
  cellCantProd.setHorizontalAlignment(Element.ALIGN_CENTER);
  cellCantProd.setPadding(5);
  tableTop.addCell(cellCantProd);
  document.add(tableTop);
  document.close();
  return baos.toByteArray();
  } catch (Exception e) {
  throw new RuntimeException("Error generando PDF reporte: " + e.getMessage(), e);
  private PdfPCell crearCeldaHeader(String texto) {
  PdfPCell cell = new PdfPCell(new Paragraph(texto, FONT_HEADER_TABLA));
  cell.setBackgroundColor(Color.DARK_GRAY);
  cell.setHorizontalAlignment(Element.ALIGN_CENTER);
  cell.setVerticalAlignment(Element.ALIGN_MIDDLE);
  cell.setPadding(8);
}
class MovimientoPuntosService {
  private MovimientoPuntosRepository movimientoPuntosRepository
  private final MovimientoPuntosMapper movimientoPuntosMapper
  public List<MovimientoPuntosDTO> getAllMovimientosPuntos() {
  return movimientoPuntosRepository.findAll().stream()
  .map(movimientoPuntosMapper::toDTO)
  .collect(Collectors.toList());
  public Optional<MovimientoPuntosDTO> getMovimientoPuntosById(Long id) {
  return movimientoPuntosRepository.findById(id)
  .map(movimientoPuntosMapper::toDTO);
  public MovimientoPuntosDTO createMovimientoPuntos(MovimientoPuntosDTO movimientoPuntosDTO) {
  MovimientoPuntos movimientoPuntos = movimientoPuntosMapper.toEntity(movimientoPuntosDTO);
  return movimientoPuntosMapper.toDTO(movimientoPuntosRepository.save(movimientoPuntos));
  public MovimientoPuntosDTO updateMovimientoPuntos(Long id, MovimientoPuntosDTO movimientoPuntosDTO) {
  MovimientoPuntos movimientoPuntos = movimientoPuntosMapper.toEntity(movimientoPuntosDTO);
  movimientoPuntos.setId(id);
  return movimientoPuntosMapper.toDTO(movimientoPuntosRepository.save(movimientoPuntos));
  public void deleteMovimientoPuntos(Long id) {
  movimientoPuntosRepository.deleteById(id);
}
class ProveedorService {
  private ProveedorRepository proveedorRepository
  private CategoriaRepository categoriaRepository
  private ProveedorMapper proveedorMapper
  List<Proveedor> proveedores
  })
  })
  public List<ProveedorDTO> findAll(String estadoStr) {
  if ("TODOS".equalsIgnoreCase(estadoStr)) {
  proveedores = proveedorRepository.findAll();
  } else if ("INACTIVO".equalsIgnoreCase(estadoStr)) {
  proveedores = proveedorRepository.findByEstado(EstadoUsuario.INACTIVO);
  proveedores = proveedorRepository.findByEstado(EstadoUsuario.ACTIVO);
  return proveedorMapper.toProveedorDTOList(proveedores);
  public ProveedorDTO findById(Long id) {
  Proveedor proveedor = proveedorRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Proveedor no encontrado con id: " + id));
  return proveedorMapper.toProveedorDTO(proveedor);
  public ProveedorDTO create(ProveedorDTO proveedorDTO) {
  proveedorRepository.findByCuit(proveedorDTO.getCuit()).ifPresent(p -> {
  throw new RuntimeException("Ya existe un proveedor con el CUIT: " + proveedorDTO.getCuit());
  Proveedor proveedor = proveedorMapper.toProveedor(proveedorDTO);
  proveedor.setEstado(EstadoUsuario.ACTIVO);
  if (proveedorDTO.getCategoriaIds() != null && !proveedorDTO.getCategoriaIds().isEmpty()) {
  Set<Categoria> categorias = proveedorDTO.getCategoriaIds().stream()
  .map(id -> categoriaRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Categoría no encontrada: " + id)))
  .collect(Collectors.toSet());
  proveedor.setCategorias(categorias);
  Proveedor proveedorGuardado = proveedorRepository.save(proveedor);
  return proveedorMapper.toProveedorDTO(proveedorGuardado);
  public ProveedorDTO update(Long id, ProveedorDTO proveedorDTO) {
  Proveedor proveedorExistente = proveedorRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Proveedor no encontrado con id: " + id));
  proveedorRepository.findByCuit(proveedorDTO.getCuit()).ifPresent(p -> {
  if (!p.getId().equals(id)) {
  throw new RuntimeException("Ya existe OTRO proveedor con el CUIT: " + proveedorDTO.getCuit());
  proveedorMapper.updateProveedorFromDto(proveedorDTO, proveedorExistente);
  if (proveedorDTO.getCategoriaIds() != null) {
  Set<Categoria> categorias = proveedorDTO.getCategoriaIds().stream()
  .map(catId -> categoriaRepository.findById(catId)
  .orElseThrow(() -> new RuntimeException("Categoría no encontrada: " + catId)))
  .collect(Collectors.toSet());
  proveedorExistente.setCategorias(categorias);
  proveedorExistente.getCategorias().clear();
  if (proveedorDTO.getEstado() != null) {
  EstadoUsuario nuevoEstado = EstadoUsuario.valueOf(proveedorDTO.getEstado().toUpperCase());
  proveedorExistente.setEstado(nuevoEstado);
  } catch (IllegalArgumentException e) {
  Proveedor actualizado = proveedorRepository.save(proveedorExistente);
  return this.findById(actualizado.getId());
  public void softDelete(Long id) {
  Proveedor proveedor = proveedorRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Proveedor no encontrado con id: " + id));
  proveedor.setEstado(EstadoUsuario.INACTIVO);
  proveedorRepository.save(proveedor);
  public void reactivar(Long id) {
  Proveedor proveedor = proveedorRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Proveedor no encontrado con id: " + id));
  proveedor.setEstado(EstadoUsuario.ACTIVO);
  proveedorRepository.save(proveedor);
}
class CotizacionService {
  BigDecimal precioTotalOfertado
  continue
  BigDecimal totalPedido
  )
  )
  })
  return pedido
  )
  BigDecimal nuevoTotal
  )
  public CotizacionPublicaDTO findCotizacionPublicaByToken(String token) {
  Cotizacion cotizacion = cotizacionRepository.findByToken(token)
  .orElseThrow(() -> new EntityNotFoundException("Solicitud de cotización no encontrada o inválida."));
  if (cotizacion.getEstado() != EstadoCotizacion.PENDIENTE_PROVEEDOR) {
  throw new IllegalStateException("Esta solicitud de cotización ya ha sido procesada o ha expirado.");
  return new CotizacionPublicaDTO(cotizacion);
  public void submitOfertaProveedor(String token, OfertaProveedorDTO ofertaDTO) {
  Cotizacion cotizacion = cotizacionRepository.findByToken(token)
  .orElseThrow(() -> new EntityNotFoundException("Solicitud de cotización no encontrada o inválida."));
  if (cotizacion.getEstado() != EstadoCotizacion.PENDIENTE_PROVEEDOR) {
  throw new IllegalStateException("Esta solicitud de cotización ya ha sido procesada o ha expirado.");
  Map<Long, ItemCotizacion> itemsMap = cotizacion.getItems().stream()
  .collect(Collectors.toMap(ItemCotizacion::getId, Function.identity()));
  for (ItemOfertaDTO itemOferta : ofertaDTO.getItems()) {
  ItemCotizacion itemDB = itemsMap.get(itemOferta.getItemCotizacionId());
  if (itemDB == null || !itemDB.getCotizacion().getId().equals(cotizacion.getId())) {
  throw new SecurityException("Intento de cotizar un item inválido.");
  if (!itemOferta.isDisponible()) {
  itemDB.setEstado(EstadoItemCotizacion.NO_DISPONIBLE_PROVEEDOR);
  itemDB.setPrecioUnitarioOfertado(BigDecimal.ZERO);
  itemDB.setPrecioUnitarioOfertado(itemOferta.getPrecioUnitarioOfertado());
  int cantidadFinal = (itemOferta.getCantidadOfertada() != null && itemOferta.getCantidadOfertada() > 0)
  ? itemOferta.getCantidadOfertada()
  : itemDB.getCantidadSolicitada();
  itemDB.setCantidadSolicitada(cantidadFinal);
  itemDB.setEstado(EstadoItemCotizacion.COTIZADO);
  BigDecimal subtotal = itemOferta.getPrecioUnitarioOfertado()
  .multiply(new BigDecimal(cantidadFinal));
  precioTotalOfertado = precioTotalOfertado.add(subtotal);
  cotizacion.setFechaEntregaOfertada(ofertaDTO.getFechaEntregaOfertada());
  cotizacion.setPrecioTotalOfertado(precioTotalOfertado);
  cotizacion.setEstado(EstadoCotizacion.RECIBIDA);
  cotizacionRepository.save(cotizacion);
  recalcularRecomendacion(cotizacion);
  public List<CotizacionAdminDTO> findCotizacionesRecibidas() {
  return cotizacionRepository.findByEstado(EstadoCotizacion.RECIBIDA).stream()
  .map(CotizacionAdminDTO::new)
  .collect(Collectors.toList());
  public CotizacionAdminDTO findCotizacionAdminById(Long id) {
  Cotizacion cotizacion = cotizacionRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Cotización no encontrada: " + id));
  return new CotizacionAdminDTO(cotizacion);
  public void cancelarItem(Long itemId) {
  ItemCotizacion item = itemCotizacionRepository.findById(itemId)
  .orElseThrow(() -> new EntityNotFoundException("Item no encontrado: " + itemId));
  if (item.getCotizacion().getEstado() != EstadoCotizacion.RECIBIDA) {
  throw new IllegalStateException("Solo se pueden cancelar items en estado RECIBIDA.");
  item.setEstado(EstadoItemCotizacion.CANCELADO_ADMIN);
  itemCotizacionRepository.save(item);
  recalcularTotalCotizacion(item.getCotizacion());
  public void cancelarCotizacion(Long id) {
  Cotizacion cotizacion = cotizacionRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Cotización no encontrada: " + id));
  if (cotizacion.getEstado() != EstadoCotizacion.RECIBIDA) {
  throw new IllegalStateException("Solo se pueden cancelar cotizaciones RECIBIDAS.");
  cotizacion.setEstado(EstadoCotizacion.CANCELADA_ADMIN);
  cotizacionRepository.save(cotizacion);
  public Pedido confirmarCotizacion(Long id, String adminEmail) {
  Usuario adminUsuario = usuarioRepository.findByEmail(adminEmail)
  .orElseThrow(() -> new EntityNotFoundException("Admin no encontrado: " + adminEmail));
  Cotizacion cotizacionGanadora = cotizacionRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Cotización no encontrada: " + id));
  if (cotizacionGanadora.getEstado() != EstadoCotizacion.RECIBIDA) {
  throw new IllegalStateException("Solo se pueden confirmar cotizaciones RECIBIDAS.");
  Pedido pedido = new Pedido();
  pedido.setFechaPedido(LocalDateTime.now());
  pedido.setEstado(EstadoPedido.PENDIENTE);
  pedido.setProveedor(cotizacionGanadora.getProveedor());
  pedido.setUsuario(adminUsuario);
  pedido.setToken(UUID.randomUUID().toString());
  Set<DetallePedido> detallesPedido = new HashSet<>();
  for (ItemCotizacion itemGanador : cotizacionGanadora.getItems()) {
  if (itemGanador.getEstado() == EstadoItemCotizacion.COTIZADO) {
  DetallePedido detalle = new DetallePedido();
  detalle.setPedido(pedido);
  detalle.setProducto(itemGanador.getProducto());
  detalle.setCantidad(itemGanador.getCantidadSolicitada());
  detalle.setPrecioUnitario(itemGanador.getPrecioUnitarioOfertado());
  detallesPedido.add(detalle);
  BigDecimal subtotal = itemGanador.getPrecioUnitarioOfertado()
  .multiply(new BigDecimal(itemGanador.getCantidadSolicitada()));
  totalPedido = totalPedido.add(subtotal);
  itemGanador.setEstado(EstadoItemCotizacion.CONFIRMADO);
  if (!itemsPerdedores.isEmpty()) {
  Set<Cotizacion> cotizacionesAfectadas = new HashSet<>();
  itemsPerdedores.forEach(perdedor -> {
  perdedor.setEstado(EstadoItemCotizacion.CANCELADO_SISTEMA);
  cotizacionesAfectadas.add(perdedor.getCotizacion());
  itemCotizacionRepository.saveAll(itemsPerdedores);
  verificarYAutoCancelarCotizaciones(cotizacionesAfectadas);
  if (detallesPedido.isEmpty()) {
  throw new IllegalStateException("No hay items cotizados válidos para crear el pedido.");
  pedido.setDetalles(detallesPedido);
  pedido.setTotalPedido(totalPedido);
  pedidoRepository.save(pedido);
  cotizacionGanadora.setEstado(EstadoCotizacion.CONFIRMADA_ADMIN);
  cotizacionRepository.save(cotizacionGanadora);
  itemCotizacionRepository.saveAll(cotizacionGanadora.getItems());
  private void verificarYAutoCancelarCotizaciones(Set<Cotizacion> cotizaciones) {
  for (Cotizacion cot : cotizaciones) {
  boolean tieneItemsVivos = cot.getItems().stream()
  if (!tieneItemsVivos) {
  cot.setEstado(EstadoCotizacion.CANCELADA_SISTEMA);
  cotizacionRepository.save(cot);
  recalcularTotalCotizacion(cot);
  private void recalcularTotalCotizacion(Cotizacion cotizacion) {
  for (ItemCotizacion item : cotizacion.getItems()) {
  if ((item.getEstado() == EstadoItemCotizacion.COTIZADO || item.getEstado() == EstadoItemCotizacion.CONFIRMADO)
  && item.getPrecioUnitarioOfertado() != null) {
  item.getPrecioUnitarioOfertado().multiply(new BigDecimal(item.getCantidadSolicitada()))
  cotizacion.setPrecioTotalOfertado(nuevoTotal);
  cotizacionRepository.save(cotizacion);
  recalcularRecomendacion(cotizacion);
  private void recalcularRecomendacion(Cotizacion cotizacionRef) {
  List<Cotizacion> competidoras = cotizacionRepository.findByEstado(EstadoCotizacion.RECIBIDA);
  if (competidoras.isEmpty()) return;
  for (Cotizacion c : competidoras) {
  c.setEsRecomendada(false);
  Cotizacion mejorOpcion = competidoras.stream()
  .max((c1, c2) -> {
  long itemsC1 = c1.getItems().stream().filter(i -> i.getEstado() == EstadoItemCotizacion.COTIZADO).count();
  long itemsC2 = c2.getItems().stream().filter(i -> i.getEstado() == EstadoItemCotizacion.COTIZADO).count();
  int compareItems = Long.compare(itemsC1, itemsC2);
  if (compareItems != 0) return compareItems;
  BigDecimal p1 = c1.getPrecioTotalOfertado() != null ? c1.getPrecioTotalOfertado() : BigDecimal.valueOf(Long.MAX_VALUE);
  BigDecimal p2 = c2.getPrecioTotalOfertado() != null ? c2.getPrecioTotalOfertado() : BigDecimal.valueOf(Long.MAX_VALUE);
  int comparePrecio = p2.compareTo(p1);
  if (comparePrecio != 0) return comparePrecio;
  LocalDate f1 = c1.getFechaEntregaOfertada() != null ? c1.getFechaEntregaOfertada() : LocalDate.MAX;
  LocalDate f2 = c2.getFechaEntregaOfertada() != null ? c2.getFechaEntregaOfertada() : LocalDate.MAX;
  return f2.compareTo(f1);
  .orElse(null);
  if (mejorOpcion != null) {
  mejorOpcion.setEsRecomendada(true);
  cotizacionRepository.saveAll(competidoras);
}
class RecompensaService {
  private RecompensaRepository recompensaRepository
  private CategoriaRepository categoriaRepository
  private RecompensaMapper recompensaMapper
  public List<RecompensaDTO> findAll() {
  return recompensaRepository.findAll().stream()
  .map(recompensaMapper::toDto)
  .collect(Collectors.toList());
  public List<RecompensaDTO> findDisponibles() {
  return recompensaRepository.findAll().stream()
  .filter(r -> Boolean.TRUE.equals(r.getActivo()) && r.getStock() > 0)
  .map(recompensaMapper::toDto)
  .collect(Collectors.toList());
  public RecompensaDTO findById(Long id) {
  Recompensa recompensa = recompensaRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Recompensa no encontrada: " + id));
  return recompensaMapper.toDto(recompensa);
  public RecompensaDTO crear(RecompensaDTO dto) {
  Recompensa recompensa = recompensaMapper.toEntity(dto);
  asignarCategoria(recompensa, dto.getCategoriaId());
  if (recompensa.getActivo() == null) recompensa.setActivo(true);
  if (recompensa.getStock() == null) recompensa.setStock(0);
  Recompensa guardada = recompensaRepository.save(recompensa);
  return recompensaMapper.toDto(guardada);
  public RecompensaDTO actualizar(Long id, RecompensaDTO dto) {
  Recompensa recompensa = recompensaRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Recompensa no encontrada: " + id));
  recompensa.setDescripcion(dto.getDescripcion());
  recompensa.setPuntosRequeridos(dto.getPuntosRequeridos());
  recompensa.setTipoDescuento(dto.getTipoDescuento());
  recompensa.setValor(dto.getValor());
  recompensa.setStock(dto.getStock());
  asignarCategoria(recompensa, dto.getCategoriaId());
  Recompensa actualizada = recompensaRepository.save(recompensa);
  return recompensaMapper.toDto(actualizada);
  public void eliminar(Long id) {
  Recompensa recompensa = recompensaRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Recompensa no encontrada: " + id));
  recompensaRepository.delete(recompensa);
  private void asignarCategoria(Recompensa recompensa, Long categoriaId) {
  if (categoriaId != null) {
  Categoria categoria = categoriaRepository.findById(categoriaId)
  .orElseThrow(() -> new EntityNotFoundException("Categoría no encontrada: " + categoriaId));
  recompensa.setCategoria(categoria);
  recompensa.setCategoria(null);
}
class CuponService {
  private CuponRepository cuponRepository
  private UsuarioRepository usuarioRepository
  private CuponMapper cuponMapper
  return cupon
  public CuponDTO crearCuponManual(Long usuarioId, BigDecimal valor, TipoDescuento tipo, int diasValidez, String motivo) {
  Usuario cliente = usuarioRepository.findById(usuarioId)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado para asignar el cupón manual."));
  Cupon cupon = new Cupon();
  cupon.setCliente(cliente);
  cupon.setValor(valor);
  cupon.setTipoDescuento(tipo);
  cupon.setEstado(EstadoCupon.VIGENTE);
  cupon.setFechaVencimiento(LocalDate.now().plusDays(diasValidez));
  cupon.setCategoria(null);
  String codigo = "ADM-" + UUID.randomUUID().toString().substring(0, 6).toUpperCase();
  cupon.setCodigo(codigo);
  Cupon cuponGuardado = cuponRepository.save(cupon);
  return cuponMapper.toCuponDTO(cuponGuardado);
  public Cupon validarCupon(String codigoCupon, Usuario cliente) {
  Cupon cupon = cuponRepository.findByCodigo(codigoCupon)
  .orElseThrow(() -> new CuponNoValidoException("El cupón '" + codigoCupon + "' no existe."));
  if (cupon.getEstado() != EstadoCupon.VIGENTE) {
  throw new CuponNoValidoException("El cupón '" + codigoCupon + "' ya fue " + cupon.getEstado() + ".");
  if (cupon.getFechaVencimiento().isBefore(LocalDate.now())) {
  throw new CuponNoValidoException("El cupón '" + codigoCupon + "' ha vencido.");
  if (!cupon.getCliente().getId().equals(cliente.getId())) {
  throw new CuponNoValidoException("Este cupón no pertenece a este cliente.");
  public void marcarCuponComoUsado(Cupon cupon, Venta venta) {
  cupon.setEstado(EstadoCupon.USADO);
  cupon.setVenta(venta);
  public List<CuponDTO> obtenerCuponesPorUsuario(String email) {
  List<Cupon> cupones = cuponRepository.findByCliente_EmailOrderByFechaVencimientoDesc(email);
  return cupones.stream()
  .map(cuponMapper::toCuponDTO)
  .toList();
  public Cupon crearCuponPorCanje(Usuario cliente, Recompensa recompensa) {
  Cupon cupon = new Cupon();
  cupon.setCliente(cliente);
  String randomSuffix = UUID.randomUUID().toString().substring(0, 4).toUpperCase();
  String codigo = String.format("CANJE-%d-%s", cliente.getId(), randomSuffix);
  cupon.setCodigo(codigo);
  cupon.setValor(recompensa.getValor());
  cupon.setTipoDescuento(recompensa.getTipoDescuento());
  cupon.setCategoria(recompensa.getCategoria());
  cupon.setEstado(EstadoCupon.VIGENTE);
  cupon.setFechaVencimiento(LocalDate.now().plusDays(90));
  return cuponRepository.save(cupon);
}
class WhatsappService {
  private String accountSid
  private String authToken
  private String fromNumber
  public void init() {
  Twilio.init(accountSid, authToken);
  } catch (Exception e) {
  logger.error("Error Twilio: {}", e.getMessage());
  public void enviarMensaje(String numeroDestino, String mensajeTexto) {
  if (numeroDestino == null || numeroDestino.isBlank()) return;
  String destinoFinal = numeroDestino.startsWith("whatsapp:") ? numeroDestino : "whatsapp:" + numeroDestino;
  String remitenteFinal = fromNumber.startsWith("whatsapp:") ? fromNumber : "whatsapp:" + fromNumber;
  ).create();
  logger.info("Mensaje enviado a {}", numeroDestino);
  } catch (Exception e) {
  logger.error("Error enviando WhatsApp: {}", e.getMessage());
}
class MovimientoStockService {
  private ProductoRepository productoRepository
  private UsuarioRepository usuarioRepository
  private MovimientoStockRepository movimientoStockRepository
  private MovimientoStockMapper movimientoStockMapper
  private AuditoriaRepository auditoriaRepository
  String motivoFinal
  int stockNuevo
  String jsonAnterior
  String jsonNuevo
  throw e
  public void registrarMovimiento(MovimientoStockDTO dto) {
  Producto producto = productoRepository.findById(dto.getProductoId())
  .orElseThrow(() -> new RuntimeException("Producto no encontrado: " + dto.getProductoId()));
  Usuario usuario = usuarioRepository.findById(dto.getUsuarioId())
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado: " + dto.getUsuarioId()));
  MovimientoStock movimiento = movimientoStockMapper.toMovimientoStock(dto);
  movimiento.setProducto(producto);
  movimiento.setUsuario(usuario);
  movimiento.setFecha(LocalDateTime.now());
  if (dto.getMotivo() != null && !dto.getMotivo().trim().isEmpty()) {
  motivoFinal = dto.getMotivo().trim();
  movimiento.setMotivo(motivoFinal);
  int cantidadGuardar = dto.getCantidad();
  dto.getTipoMovimiento() == TipoMovimiento.DEVOLUCION) {
  cantidadGuardar = -Math.abs(cantidadGuardar);
  movimiento.setCantidad(cantidadGuardar);
  movimientoStockRepository.save(movimiento);
  registrarEnAuditoriaGeneral(producto, usuario, dto.getTipoMovimiento(), cantidadGuardar, motivoFinal);
  private void registrarEnAuditoriaGeneral(Producto producto, Usuario usuario, TipoMovimiento tipo, int cantidad, String motivo) {
  System.out.println(">>> [SERVICE] Intentando crear auditoría para: " + producto.getNombre());
  Auditoria audit = new Auditoria();
  audit.setFecha(LocalDateTime.now());
  audit.setUsuario(usuario != null ? usuario.getEmail() : "sistema@masterserv.com");
  audit.setEntidad("Producto");
  audit.setEntidadId(producto.getId().toString());
  audit.setAccion("AJUSTE_MANUAL");
  String nombreCategoria = (producto.getCategoria() != null) ? producto.getCategoria().getNombre() : "Sin Categoría";
  producto.getNombre(), nombreCategoria, tipo, cantidad, motivo);
  if (detalleCompleto.length() > 255) detalleCompleto = detalleCompleto.substring(0, 255);
  audit.setDetalle(detalleCompleto);
  int stockAnterior = producto.getStockActual();
  audit.setValorAnterior(jsonAnterior);
  audit.setValorNuevo(jsonNuevo);
  System.out.println(">>> [SERVICE] Guardando en repositorio...");
  auditoriaRepository.save(audit);
  auditoriaRepository.flush();
  System.out.println(">>> [SERVICE] ¡GUARDADO EXITOSO! ID Generado: " + audit.getId());
  } catch (Exception e) {
  System.err.println(">>> [ERROR CRÍTICO] Falló el guardado de auditoría:");
  e.printStackTrace();
}
class CustomUserDetailsService {
  private UsuarioRepository usuarioRepository
  )
  })
  })
  return authorities
  public UserDetails loadUserByUsername(String email)
  Usuario usuario = usuarioRepository.findByEmail(email)
  new UsernameNotFoundException("Usuario no encontrado con email: " + email));
  Collection<? extends GrantedAuthority> authorities = mapRolesAndPermissionsToAuthorities(usuario.getRoles());
  private Collection<? extends GrantedAuthority> mapRolesAndPermissionsToAuthorities(Set<Rol> roles) {
  Set<GrantedAuthority> authorities = new HashSet<>();
  roles.forEach(rol -> {
  authorities.add(new SimpleGrantedAuthority(rol.getNombreRol()));
  rol.getPermisos().forEach(permiso -> {
  authorities.add(new SimpleGrantedAuthority(permiso.getNombrePermiso()));
}
UserDetailsService <|.. CustomUserDetailsService
class ReglaPuntosService {
  private static final String ESTADO_ACTIVO
  private ReglaPuntosRepository reglaPuntosRepository
  private ReglaPuntosMapper reglaPuntosMapper
  })
  public Optional<ReglaPuntos> getReglaActiva() {
  return reglaPuntosRepository.findByEstadoRegla(ESTADO_ACTIVO);
  public Optional<ReglaPuntosDTO> getReglaActivaDTO() {
  return getReglaActiva()
  .map(reglaPuntosMapper::toReglaPuntosDTO);
  public List<ReglaPuntosDTO> findAll() {
  return reglaPuntosMapper.toReglaPuntosDTOList(reglaPuntosRepository.findAll());
  public ReglaPuntosDTO createOrUpdateRegla(ReglaPuntosDTO nuevaReglaDTO) {
  reglaPuntosRepository.findByEstadoRegla(ESTADO_ACTIVO).ifPresent(reglaAnterior -> {
  reglaAnterior.setEstadoRegla("CADUCADA");
  reglaPuntosRepository.save(reglaAnterior);
  ReglaPuntos nuevaRegla = reglaPuntosMapper.toReglaPuntos(nuevaReglaDTO);
  nuevaRegla.setEstadoRegla(ESTADO_ACTIVO);
  if (nuevaRegla.getEquivalenciaPuntos() == null) {
  nuevaRegla.setEquivalenciaPuntos(new BigDecimal("1.00"));
  if (nuevaRegla.getId() != null && nuevaRegla.getId() != 0) {
  nuevaRegla.setId(null);
  ReglaPuntos reglaGuardada = reglaPuntosRepository.save(nuevaRegla);
  return reglaPuntosMapper.toReglaPuntosDTO(reglaGuardada);
}
class ChatbotService {
  private final UsuarioRepository usuarioRepository
  private final ProductoRepository productoRepository
  private final InteraccionChatbotRepository interaccionRepository
  private final PuntosService puntosService
  private final SolicitudProductoRepository solicitudProductoRepository
  private final RecompensaRepository recompensaRepository
  private final CuentaPuntosRepository cuentaPuntosRepository
  private final ListaEsperaRepository listaEsperaRepository
  private final CuponService cuponService
  this.usuarioRepository
  this.productoRepository
  this.interaccionRepository
  this.puntosService
  this.solicitudProductoRepository
  this.recompensaRepository
  this.cuentaPuntosRepository
  this.listaEsperaRepository
  this.cuponService
  String texto
  String mediaUrl
  BotResponse respuesta
  )
  )
  boolean hayStock
  hayStock
  return false
  List<Producto> productos
  )
  String disponibilidad
  disponibilidad
  : "Consultar"
  return "🚫 Te faltan puntos para este premio."
  return "🔥 Hubo un error técnico. Por favor intenta más tarde."
  String[] prefijos
  return texto
  public String procesarMensajeWebhook(String from, String body) {
  System.out.println("--- 📩 WHATSAPP ENTRANTE: " + body + " ---");
  String telefono = from.replace("whatsapp:", "").trim();
  Optional<Usuario> usuarioOpt = usuarioRepository.findByTelefono(telefono);
  respuesta = procesarComando(body.trim(), usuarioOpt);
  } catch (Exception e) {
  e.printStackTrace();
  respuesta = new BotResponse("😓 Ups, me mareé un poco. ¿Podrías intentar de nuevo en un momento?");
  return construirRespuestaTwiML(respuesta);
  private BotResponse procesarComando(String comandoOriginal, Optional<Usuario> usuarioOpt) {
  String texto = normalizarTexto(comandoOriginal);
  if (usuarioOpt.isEmpty()) {
  Usuario usuario = usuarioOpt.get();
  if (detectarIntencion(texto, List.of("hola", "buenas", "hi", "que tal", "inicio", "menu", "ayuda", "opciones", "empezar"))) {
  usuario.getNombre()
  if (detectarIntencion(texto, List.of("punto", "saldo", "premio", "fidelidad", "canje"))) {
  var saldoDTO = puntosService.getSaldoByEmail(usuario.getEmail());
  int puntosActuales = saldoDTO.getSaldoPuntos();
  List<Recompensa> recompensas = recompensaRepository.findAll();
  StringBuilder msg = new StringBuilder();
  msg.append(String.format("🏆 *Tienes %d Puntos acumulados* 👏\n\n🎁 *Mira lo que puedes canjear:*\n", puntosActuales));
  for (Recompensa r : recompensas) {
  if (Boolean.TRUE.equals(r.getActivo()) && r.getStock() > 0) {
  String estado = (puntosActuales >= r.getPuntosRequeridos()) ? "✅" : "🔒";
  msg.append(String.format("\n%s *%s* (%d pts)", estado, r.getDescripcion(), r.getPuntosRequeridos()));
  if (!hayStock) msg.append("\n_Por el momento no hay stock de premios._");
  else msg.append("\n\nPara canjear uno, escribe: *\"canjear [nombre]\"*");
  return new BotResponse(msg.toString());
  if (texto.startsWith("canjear")) {
  String nombrePremio = limpiarPrefijo(texto);
  if (nombrePremio.isEmpty()) return new BotResponse("⚠️ Ups, te faltó decirme qué quieres canjear.\nEjemplo: *canjear gorra*");
  return new BotResponse(procesarCanje(usuario, nombrePremio));
  if (texto.startsWith("solicitar") || texto.startsWith("pedir") || texto.startsWith("quiero") || texto.startsWith("necesito")) {
  return procesarSolicitud(usuario, limpiarPrefijo(texto));
  if (texto.length() > 2) {
  return buscarProducto(texto);
  return new BotResponse("🤔 No estoy seguro de qué necesitas.\nPrueba escribiendo el nombre del repuesto (ej: *\"bujia\"*) o escribe *\"Hola\"* para ver el menú.");
  private String normalizarTexto(String input) {
  if (input == null) return "";
  String normalized = Normalizer.normalize(input, Normalizer.Form.NFD);
  return normalized.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "")
  .replaceAll("[^a-zA-Z0-9\\s]", "")
  .toLowerCase()
  .trim();
  private boolean detectarIntencion(String textoUsuario, List<String> palabrasClave) {
  boolean contiene = palabrasClave.stream().anyMatch(k -> textoUsuario.contains(k));
  if (contiene) return true;
  String[] palabrasUser = textoUsuario.split("\\s+");
  LevenshteinDistance levenshtein = new LevenshteinDistance();
  for (String pUser : palabrasUser) {
  for (String clave : palabrasClave) {
  if (Math.abs(pUser.length() - clave.length()) > 2) continue;
  if (levenshtein.apply(pUser, clave) <= 1) return true;
  private BotResponse buscarProducto(String termino) {
  Optional<Producto> productoPorCodigo = productoRepository.findByCodigo(termino.toUpperCase());
  if (productoPorCodigo.isPresent()) {
  return formatearRespuestaProducto(productoPorCodigo.get());
  Pageable top5 = PageRequest.of(0, 5);
  Page<Producto> page = productoRepository.buscarFlexible(termino, top5);
  productos = page.getContent();
  } catch (Exception e) {
  productos = productoRepository.findByNombreILike(termino, top5);
  if (productos.isEmpty()) {
  } else if (productos.size() == 1) {
  return formatearRespuestaProducto(productos.get(0));
  StringBuilder respuesta = new StringBuilder("🔎 *Encontré estas opciones:*\n");
  for (Producto p : productos) {
  String precio = (p.getPrecioVenta() != null) ? String.format("$%,.0f", p.getPrecioVenta().doubleValue()) : "Consultar";
  respuesta.append(String.format("\n▪ %s (%s)", p.getNombre(), precio));
  respuesta.append("\n\n👇 *Escribe el nombre completo* de uno para ver la foto.");
  return new BotResponse(respuesta.toString());
  private BotResponse formatearRespuestaProducto(Producto p) {
  if (p.getStockActual() <= 0) {
  } else if (p.getStockActual() <= p.getStockMinimo()) {
  disponibilidad = "🟡 Pocas Unidades (" + p.getStockActual() + ")";
  disponibilidad = "🟢 Disponible (" + p.getStockActual() + ")";
  String precioStr = (p.getPrecioVenta() != null)
  ? String.format("$%,.2f", p.getPrecioVenta().doubleValue())
  StringBuilder sb = new StringBuilder();
  sb.append("📦 *").append(p.getNombre()).append("*\n\n");
  sb.append("💲 Precio: *").append(precioStr).append("*\n");
  sb.append("📊 Estado: ").append(disponibilidad).append("\n");
  sb.append("🏷️ Código: ").append(p.getCodigo()).append("\n\n");
  sb.append("📍 *Te esperamos en el local.*");
  String imagen = (p.getImagenUrl() != null && p.getImagenUrl().startsWith("http"))
  ? p.getImagenUrl() : null;
  return new BotResponse(sb.toString(), imagen);
  private BotResponse procesarSolicitud(Usuario usuario, String termino) {
  if (termino.length() < 3) return new BotResponse("⚠️ Escribe qué producto necesitas. Ej: *quiero espejo retrovisor*");
  SolicitudProducto s = new SolicitudProducto(termino, usuario);
  solicitudProductoRepository.save(s);
  return new BotResponse("📝 ¡Anotado! Le pasaré tu pedido de *\"" + termino + "\"* al encargado de compras.");
  private String procesarCanje(Usuario usuario, String nombrePremio) {
  Optional<Recompensa> recompensaOpt = recompensaRepository.findByDescripcionContainingIgnoreCase(nombrePremio)
  .stream().findFirst();
  if (recompensaOpt.isEmpty()) return "❌ No encuentro ese premio. Revisa el nombre exacto en el menú de *Premios*.";
  Recompensa recompensa = recompensaOpt.get();
  if (recompensa.getStock() <= 0) return "😓 Uy, se agotó ese premio. ¡Lo siento!";
  var cuentaOpt = cuentaPuntosRepository.findByCliente(usuario);
  if (cuentaOpt.isEmpty() || cuentaOpt.get().getSaldoPuntos() < recompensa.getPuntosRequeridos()) {
  CuentaPuntos cuenta = cuentaOpt.get();
  cuenta.setSaldoPuntos(cuenta.getSaldoPuntos() - recompensa.getPuntosRequeridos());
  cuentaPuntosRepository.save(cuenta);
  recompensa.setStock(recompensa.getStock() - 1);
  recompensaRepository.save(recompensa);
  Cupon cupon = cuponService.crearCuponPorCanje(usuario, recompensa);
  return "🎉 *¡CANJE EXITOSO!* 🎉\nTu código es:\n\n👉 *" + cupon.getCodigo() + "*\n\nMuéstralo en caja (Vence en 90 días).";
  } catch (Exception e) {
  e.printStackTrace();
  private String limpiarPrefijo(String texto) {
  for (String prefijo : prefijos) {
  if (texto.startsWith(prefijo)) return texto.substring(prefijo.length()).trim();
  private void registrarInteraccion(String in, String out, Usuario u) {
  InteraccionChatbot i = new InteraccionChatbot();
  i.setFecha(LocalDateTime.now());
  i.setMensajeUsuario(in);
  i.setRespuestaBot(out);
  i.setUsuario(u);
  interaccionRepository.save(i);
  private String construirRespuestaTwiML(BotResponse respuesta) {
  Message.Builder messageBuilder = new Message.Builder();
  messageBuilder.body(new Body.Builder(respuesta.texto).build());
  if (respuesta.mediaUrl != null && !respuesta.mediaUrl.isEmpty()) {
  messageBuilder.media(new Media.Builder(respuesta.mediaUrl).build());
  return new MessagingResponse.Builder().message(messageBuilder.build()).build().toXml();
}
class BotResponse {
  String texto
  String mediaUrl
}
class PermisoService {
  private PermisoRepository permisoRepository
  private PermisoMapper permisoMapper
  })
  public List<PermisoDTO> listarPermisos() {
  List<Permiso> permisos = permisoRepository.findAll();
  return permisoMapper.toPermisoDTOList(permisos);
  public PermisoDTO crear(PermisoDTO permisoDTO) {
  permisoRepository.findByNombrePermiso(permisoDTO.getNombrePermiso()).ifPresent(p -> {
  throw new RuntimeException("Ya existe un permiso con el nombre: " + permisoDTO.getNombrePermiso());
  Permiso permiso = permisoMapper.toPermiso(permisoDTO);
  Permiso guardado = permisoRepository.save(permiso);
  return permisoMapper.toPermisoDTO(guardado);
  public PermisoDTO actualizar(PermisoDTO permisoDTO) {
  Permiso permisoExistente = permisoRepository.findById(permisoDTO.getId())
  .orElseThrow(() -> new RuntimeException("Permiso no encontrado"));
  Optional<Permiso> checkNombre = permisoRepository.findByNombrePermiso(permisoDTO.getNombrePermiso());
  if (checkNombre.isPresent() && !checkNombre.get().getId().equals(permisoDTO.getId())) {
  throw new RuntimeException("Ya existe otro permiso con ese nombre.");
  permisoExistente.setNombrePermiso(permisoDTO.getNombrePermiso());
  permisoExistente.setDescripcion(permisoDTO.getDescripcion());
  Permiso actualizado = permisoRepository.save(permisoExistente);
  return permisoMapper.toPermisoDTO(actualizado);
  public void softDelete(Long id) {
  Permiso permiso = permisoRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Permiso no encontrado"));
  permisoRepository.delete(permiso);
}
class AuthService {
  private AuthenticationManager authenticationManager
  private JwtTokenUtil jwtTokenUtil
  private UsuarioRepository usuarioRepository
  private RolRepository rolRepository
  private TipoDocumentoRepository tipoDocumentoRepository
  private PasswordEncoder passwordEncoder
  private PasswordResetTokenRepository tokenRepository
  private EmailService emailService
  )
  )
  TipoDocumento tipoDoc
  public AuthResponseDTO login(LoginRequestDTO request) {
  new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())
  UserDetails userDetails = (UserDetails) authentication.getPrincipal();
  Usuario usuario = usuarioRepository.findByEmail(request.getEmail())
  .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
  String token = jwtTokenUtil.generateToken(usuario);
  List<String> roles = userDetails.getAuthorities().stream()
  .map(GrantedAuthority::getAuthority)
  .filter(auth -> auth.startsWith("ROLE_"))
  .collect(Collectors.toList());
  List<String> permisos = userDetails.getAuthorities().stream()
  .map(GrantedAuthority::getAuthority)
  .filter(auth -> !auth.startsWith("ROLE_"))
  .collect(Collectors.toList());
  usuario.isDebeCambiarPassword()
  public void register(RegisterRequestDTO request) {
  if (usuarioRepository.existsByEmail(request.getEmail())) {
  throw new RuntimeException("Error: El email ya está registrado.");
  Rol rolPorDefecto = rolRepository.findByNombreRol("ROLE_CLIENTE")
  .orElseThrow(() -> new RuntimeException("Error: Rol 'ROLE_CLIENTE' no encontrado."));
  if (request.getTipoDocumentoId() != null) {
  tipoDoc = tipoDocumentoRepository.findById(request.getTipoDocumentoId()).orElse(null);
  Usuario nuevoUsuario = new Usuario();
  nuevoUsuario.setNombre(request.getNombre());
  nuevoUsuario.setApellido(request.getApellido());
  nuevoUsuario.setEmail(request.getEmail());
  nuevoUsuario.setPasswordHash(passwordEncoder.encode(request.getPassword()));
  nuevoUsuario.setDocumento(request.getDocumento());
  nuevoUsuario.setTelefono(request.getTelefono());
  nuevoUsuario.setTipoDocumento(tipoDoc);
  nuevoUsuario.setRoles(Set.of(rolPorDefecto));
  nuevoUsuario.setEstado(EstadoUsuario.ACTIVO);
  usuarioRepository.save(nuevoUsuario);
  emailService.sendWelcomeEmail(nuevoUsuario.getEmail(), nuevoUsuario.getNombre());
  System.out.println("📧 Correo de bienvenida enviado a: " + nuevoUsuario.getEmail());
  } catch (Exception e) {
  System.err.println("❌ Error enviando correo de bienvenida: " + e.getMessage());
  public void cambiarPasswordInicial(String email, String nuevaPassword) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));
  usuario.setPasswordHash(passwordEncoder.encode(nuevaPassword));
  usuario.setDebeCambiarPassword(false);
  usuarioRepository.save(usuario);
  public void solicitarRecuperacionPassword(String email) {
  Usuario usuario = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("No existe un usuario con ese email."));
  tokenRepository.deleteByUsuario(usuario);
  String token = UUID.randomUUID().toString();
  PasswordResetToken resetToken = new PasswordResetToken(token, usuario);
  tokenRepository.save(resetToken);
  emailService.sendPasswordResetEmail(usuario.getEmail(), usuario.getNombre(), token);
  } catch (Exception e) {
  throw new RuntimeException("Error enviando el correo. Intenta más tarde.");
  public void restablecerPasswordConToken(String token, String nuevaPassword) {
  PasswordResetToken resetToken = tokenRepository.findByToken(token)
  .orElseThrow(() -> new RuntimeException("El enlace es inválido o ha expirado."));
  if (resetToken.estaExpirado()) {
  tokenRepository.delete(resetToken);
  throw new RuntimeException("El enlace ha expirado. Solicita uno nuevo.");
  Usuario usuario = resetToken.getUsuario();
  usuario.setPasswordHash(passwordEncoder.encode(nuevaPassword));
  usuarioRepository.save(usuario);
  tokenRepository.delete(resetToken);
}
class EmailService {
  private JavaMailSender mailSender
  String asunto
  <div style
  <div style
  <h1 style
  <div style
  <p style
  String asunto
  <div style
  <div style
  <h2 style
  <div style
  <div style
  <a href
  <p style
  return
  public void sendWelcomeEmail(String para, String nombre) {
  """.formatted(nombre);
  enviarEmailHtml(para, asunto, cuerpoHtml);
  public void sendPasswordResetEmail(String para, String nombre, String token) {
  """.formatted(nombre, urlFrontend);
  enviarEmailHtml(para, asunto, cuerpoHtml);
  public void enviarEmail(String para, String asunto, String cuerpo) {
  enviarEmailHtml(para, asunto, cuerpo);
  public void enviarEmailHtml(String para, String asunto, String cuerpoHtml) {
  MimeMessage mimeMessage = mailSender.createMimeMessage();
  MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, "utf-8");
  helper.setTo(para);
  helper.setSubject(asunto);
  helper.setText(cuerpoHtml, true);
  helper.setFrom("no-reply@masterserv360.com");
  mailSender.send(mimeMessage);
  logger.info("-> 📧 Email enviado a: {}", para);
  } catch (Exception e) {
  logger.error("-> 🔴 Error al enviar email a {}: {}", para, e.getMessage());
  public void enviarEmailConAdjunto(String para, String asunto, String cuerpoHtml, byte[] adjuntoBytes, String adjuntoNombre) {
  if (adjuntoBytes == null || adjuntoBytes.length == 0) {
  logger.warn("EmailService: Se intentó enviar un email a {} con un adjunto nulo o vacío.", para);
  MimeMessage mimeMessage = mailSender.createMimeMessage();
  MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "utf-8");
  helper.setTo(para);
  helper.setSubject(asunto);
  helper.setText(cuerpoHtml, true);
  helper.setFrom("comprobantes@masterserv360.com");
  ByteArrayDataSource dataSource = new ByteArrayDataSource(adjuntoBytes, "application/pdf");
  helper.addAttachment(adjuntoNombre, dataSource);
  mailSender.send(mimeMessage);
  logger.info("-> 📧 Email con PDF adjunto ({}) enviado a: {}", adjuntoNombre, para);
  } catch (Exception e) {
  logger.error("-> 🔴 Error al enviar email con adjunto a {}: {}", para, e.getMessage());
}
class CategoriaService {
  private CategoriaRepository categoriaRepository
  private CategoriaMapper categoriaMapper
  List<Categoria> categorias
  })
  })
  public List<CategoriaDTO> findAll(String estado) {
  if ("TODOS".equalsIgnoreCase(estado)) {
  categorias = categoriaRepository.findAll();
  } else if ("INACTIVO".equalsIgnoreCase(estado)) {
  categorias = categoriaRepository.findByEstado("INACTIVO");
  categorias = categoriaRepository.findByEstado("ACTIVO");
  return categoriaMapper.toCategoriaDTOList(categorias);
  public CategoriaDTO findById(Long id) {
  Categoria categoria = categoriaRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Categoría no encontrada con id: " + id));
  return categoriaMapper.toCategoriaDTO(categoria);
  public CategoriaDTO create(CategoriaDTO categoriaDTO) {
  categoriaRepository.findByNombre(categoriaDTO.getNombre()).ifPresent(c -> {
  throw new RuntimeException("Ya existe una categoría con el nombre: " + categoriaDTO.getNombre());
  Categoria categoria = categoriaMapper.toCategoria(categoriaDTO);
  categoria.setEstado("ACTIVO");
  Categoria categoriaGuardada = categoriaRepository.save(categoria);
  return categoriaMapper.toCategoriaDTO(categoriaGuardada);
  public CategoriaDTO update(Long id, CategoriaDTO categoriaDTO) {
  Categoria categoriaExistente = categoriaRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Categoría no encontrada con id: " + id));
  categoriaRepository.findByNombre(categoriaDTO.getNombre()).ifPresent(c -> {
  if (!c.getId().equals(id)) {
  throw new RuntimeException("Ya existe otra categoría con el nombre: " + categoriaDTO.getNombre());
  categoriaMapper.updateCategoriaFromDto(categoriaDTO, categoriaExistente);
  if (categoriaDTO.getEstado() != null) {
  categoriaExistente.setEstado(categoriaDTO.getEstado());
  Categoria categoriaActualizada = categoriaRepository.save(categoriaExistente);
  return categoriaMapper.toCategoriaDTO(categoriaActualizada);
  public void softDelete(Long id) {
  Categoria categoria = categoriaRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Categoría no encontrada con id: " + id));
  categoria.setEstado("INACTIVO");
  categoriaRepository.save(categoria);
  public void reactivar(Long id) {
  Categoria categoria = categoriaRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Categoría no encontrada con id: " + id));
  categoria.setEstado("ACTIVO");
  categoriaRepository.save(categoria);
}
class ProductoService {
  String prefixCompleto
  int siguienteNumero
  siguienteNumero
  })
  )
  int stockNuevo
  ))
  return productoGuardado
  int stockNuevo
  ))
  return productoGuardado
  int nuevoStock
  public String generarCodigoAutomatico(Long categoriaId, String nombreProducto) {
  Categoria categoria = categoriaRepository.findById(categoriaId)
  .orElseThrow(() -> new EntityNotFoundException("Categoría no encontrada"));
  String catNombre = categoria.getNombre().trim().toUpperCase().replaceAll("[^A-Z]", "");
  String prodNombre = nombreProducto.trim().toUpperCase().replaceAll("[^A-Z]", "");
  if (catNombre.length() < 1) catNombre = "CAT";
  if (prodNombre.length() < 1) prodNombre = "PROD";
  String catPrefix = catNombre.substring(0, Math.min(2, catNombre.length()));
  String prodPrefix = prodNombre.substring(0, Math.min(2, prodNombre.length()));
  Optional<Producto> ultimo = productoRepository.findTopByCodigoStartingWithOrderByCodigoDesc(prefixCompleto);
  if (ultimo.isPresent()) {
  String ultimoCodigo = ultimo.get().getCodigo();
  String numeroStr = ultimoCodigo.substring(prefixCompleto.length());
  siguienteNumero = Integer.parseInt(numeroStr) + 1;
  } catch (NumberFormatException | StringIndexOutOfBoundsException e) {
  return prefixCompleto + String.format("%02d", siguienteNumero);
  public Page<ProductoDTO> findAll(Pageable pageable) {
  Page<Producto> productosPage = productoRepository.findAll(pageable);
  return productosPage.map(productoMapper::toProductoDTO);
  public Page<ProductoDTO> filter(ProductoFiltroDTO filtro, Pageable pageable) {
  if (filtro.getNombre() != null && !filtro.getNombre().isBlank()) {
  Page<Producto> productosPage = productoRepository.buscarFlexible(filtro.getNombre(), pageable);
  return productosPage.map(productoMapper::toProductoDTO);
  Specification<Producto> spec = productoSpecification.getProductosByFilters(filtro);
  Page<Producto> productosPage = productoRepository.findAll(spec, pageable);
  return productosPage.map(productoMapper::toProductoDTO);
  public ProductoDTO findById(Long id) {
  Producto producto = productoRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado con ID: " + id));
  return productoMapper.toProductoDTO(producto);
  public ProductoDTO create(ProductoDTO productoDTO) {
  if (productoRepository.existsByCodigo(productoDTO.codigo())) {
  throw new IllegalArgumentException("Ya existe un producto con el código: " + productoDTO.codigo());
  Categoria categoria = categoriaRepository.findById(productoDTO.categoriaId())
  .orElseThrow(() -> new EntityNotFoundException("Error al crear producto: La Categoría con ID " + productoDTO.categoriaId() + " no existe."));
  Producto producto = productoMapper.toProducto(productoDTO);
  producto.setCategoria(categoria);
  producto.setEstado("ACTIVO");
  if (producto.getPrecioCosto() == null) {
  producto.setPrecioCosto(BigDecimal.ZERO);
  producto.setStockActual(0);
  Producto productoGuardado = productoRepository.save(producto);
  if (productoDTO.getSolicitudId() != null) {
  procesarSolicitudPorId(productoDTO.getSolicitudId(), productoGuardado);
  vincularSolicitudesPorNombre(productoGuardado);
  return productoMapper.toProductoDTO(productoGuardado);
  private void procesarSolicitudPorId(Long solicitudId, Producto producto) {
  solicitudProductoRepository.findById(solicitudId).ifPresent(solicitud -> {
  agregarAListaEspera(solicitud.getUsuario(), producto);
  solicitud.setProcesado(true);
  solicitudProductoRepository.save(solicitud);
  private void vincularSolicitudesPorNombre(Producto producto) {
  .findByDescripcionContainingIgnoreCaseAndProcesadoFalse(producto.getNombre());
  if (solicitudes.isEmpty()) return;
  for (SolicitudProducto solicitud : solicitudes) {
  agregarAListaEspera(solicitud.getUsuario(), producto);
  solicitud.setProcesado(true);
  solicitudProductoRepository.saveAll(solicitudes);
  private void agregarAListaEspera(Usuario usuario, Producto producto) {
  usuario.getId(), producto.getId(), EstadoListaEspera.PENDIENTE);
  if (!yaEsta) {
  ListaEspera espera = new ListaEspera();
  espera.setUsuario(usuario);
  espera.setProducto(producto);
  espera.setFechaInscripcion(LocalDate.now());
  espera.setEstado(EstadoListaEspera.PENDIENTE);
  listaEsperaRepository.save(espera);
  public ProductoDTO update(Long id, ProductoDTO productoDTO) {
  Producto productoExistente = productoRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado con ID: " + id));
  productoMapper.updateProductoFromDto(productoDTO, productoExistente);
  !productoDTO.categoriaId().equals(productoExistente.getCategoria().getId())) {
  Categoria categoria = categoriaRepository.findById(productoDTO.categoriaId())
  .orElseThrow(() -> new EntityNotFoundException("Categoría no encontrada: " + productoDTO.categoriaId()));
  productoExistente.setCategoria(categoria);
  if (productoDTO.estado() != null) {
  productoExistente.setEstado(productoDTO.estado());
  Producto productoActualizado = productoRepository.save(productoExistente);
  return productoMapper.toProductoDTO(productoActualizado);
  public void softDelete(Long id) {
  Producto producto = productoRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado con ID: " + id));
  producto.setEstado("INACTIVO");
  productoRepository.save(producto);
  public List<ProductoDTO> findByProveedorId(Long proveedorId) {
  List<Producto> productos = productoRepository.findActivosByProveedorId(proveedorId);
  return productos.stream()
  .map(productoMapper::toProductoDTO)
  .collect(Collectors.toList());
  public Page<ProductoDTO> searchByProveedor(Long proveedorId, String search, Pageable pageable) {
  Page<Producto> productosPage = productoRepository.searchByProveedor(proveedorId, search, pageable);
  return productosPage.map(productoMapper::toProductoDTO);
  public Page<ProductoPublicoDTO> findAllPublico(Pageable pageable) {
  ProductoFiltroDTO filtroVacio = new ProductoFiltroDTO();
  filtroVacio.setEstado("ACTIVO");
  Specification<Producto> spec = productoSpecification.getProductosByFilters(filtroVacio);
  Page<Producto> productosPage = productoRepository.findAll(spec, pageable);
  return productosPage.map(productoMapper::toProductoPublicoDTO);
  public Page<ProductoPublicoDTO> findPublicoByCriteria(ProductoPublicoFiltroDTO filtroPublico, Pageable pageable) {
  if (filtroPublico.getNombre() != null && !filtroPublico.getNombre().isBlank()) {
  Page<Producto> productosPage = productoRepository.buscarFlexible(filtroPublico.getNombre(), pageable);
  return productosPage.map(productoMapper::toProductoPublicoDTO);
  ProductoFiltroDTO filtroInterno = new ProductoFiltroDTO();
  filtroInterno.setNombre(filtroPublico.getNombre());
  filtroInterno.setCategoriaIds(filtroPublico.getCategoriaIds());
  filtroInterno.setPrecioMin(filtroPublico.getPrecioMin());
  filtroInterno.setPrecioMax(filtroPublico.getPrecioMax());
  filtroInterno.setSoloConStock(filtroPublico.getSoloConStock());
  filtroInterno.setEstado("ACTIVO");
  Specification<Producto> spec = productoSpecification.getProductosByFilters(filtroInterno);
  Page<Producto> productosPage = productoRepository.findAll(spec, pageable);
  return productosPage.map(productoMapper::toProductoPublicoDTO);
  public Producto descontarStock(Long productoId, int cantidadADescontar) {
  if (cantidadADescontar <= 0) {
  throw new IllegalArgumentException("La cantidad a descontar debe ser positiva.");
  Producto producto = productoRepository.findById(productoId)
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado: ID " + productoId));
  int stockAnterior = producto.getStockActual();
  if (stockAnterior < cantidadADescontar) {
  producto.setStockActual(stockNuevo);
  Producto productoGuardado = productoRepository.save(producto);
  public Producto reponerStock(Long productoId, int cantidadAReponer) {
  return reponerStock(productoId, cantidadAReponer, null);
  public Producto reponerStock(Long productoId, int cantidadAReponer, BigDecimal nuevoCosto) {
  if (cantidadAReponer <= 0) {
  throw new IllegalArgumentException("La cantidad a reponer debe ser positiva.");
  Producto producto = productoRepository.findById(productoId)
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado: ID " + productoId));
  int stockAnterior = producto.getStockActual();
  producto.setStockActual(stockNuevo);
  if (nuevoCosto != null && nuevoCosto.compareTo(BigDecimal.ZERO) > 0) {
  producto.setPrecioCosto(nuevoCosto);
  Producto productoGuardado = productoRepository.save(producto);
  public void ajustarStock(MovimientoStockDTO dto, String emailUsuario) {
  Producto producto = productoRepository.findById(dto.getProductoId())
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado"));
  Usuario usuario = usuarioRepository.findByEmail(emailUsuario)
  .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado: " + emailUsuario));
  int stockAnterior = producto.getStockActual();
  int cantidadAjuste = dto.getCantidad();
  if (nuevoStock < 0) {
  throw new StockInsuficienteException("El ajuste dejaría el stock en negativo (" + nuevoStock + ").");
  producto.setStockActual(nuevoStock);
  productoRepository.save(producto);
  MovimientoStock movimiento = new MovimientoStock();
  movimiento.setFecha(LocalDateTime.now());
  movimiento.setCantidad(cantidadAjuste);
  movimiento.setTipoMovimiento(TipoMovimiento.AJUSTE_MANUAL);
  movimiento.setMotivo(dto.getMotivo());
  movimiento.setProducto(producto);
  movimiento.setUsuario(usuario);
  movimientoStockRepository.save(movimiento);
  eventPublisher.publishEvent(new StockActualizadoEvent(producto.getId(), stockAnterior, nuevoStock));
}
class RolService {
  private RolRepository rolRepository
  private RolMapper rolMapper
  private PermisoRepository permisoRepository
  private PermisoMapper permisoMapper
  })
  })
  private Set<Permiso> getPermissoEntities(List<PermisoDTO> permisoDTOs) {
  if (permisoDTOs == null || permisoDTOs.isEmpty()) {
  return Collections.emptySet();
  Set<Long> ids = permisoDTOs.stream()
  .map(PermisoDTO::getId)
  .collect(Collectors.toSet());
  List<Permiso> permisos = permisoRepository.findAllById(ids);
  if (permisos.size() != ids.size()) {
  throw new RuntimeException("Error de integridad: Uno o más permisos seleccionados no existen.");
  return new HashSet<>(permisos);
  public List<RolDTO> findAll() {
  List<Rol> roles = rolRepository.findAll();
  return rolMapper.toRolDTOList(roles);
  public RolDTO create(RolDTO rolDTO) {
  rolRepository.findByNombreRol(rolDTO.getNombreRol()).ifPresent(r -> {
  throw new RuntimeException("Ya existe un rol con el nombre: " + rolDTO.getNombreRol());
  Rol rol = rolMapper.toRol(rolDTO);
  Set<Permiso> permisos = getPermissoEntities(rolDTO.getPermisos());
  rol.setPermisos(permisos);
  Rol rolGuardado = rolRepository.save(rol);
  return rolMapper.toRolDTO(rolGuardado);
  public RolDTO update(Long id, RolDTO rolDTO) {
  Rol rolExistente = rolRepository.findById(id)
  .orElseThrow(() -> new RuntimeException("Rol no encontrado con ID: " + id));
  rolRepository.findByNombreRol(rolDTO.getNombreRol()).ifPresent(r -> {
  if (!r.getId().equals(id)) {
  throw new RuntimeException("Ya existe otro rol con ese nombre: " + rolDTO.getNombreRol());
  rolMapper.updateRolFromDto(rolDTO, rolExistente);
  Set<Permiso> nuevosPermisos = getPermissoEntities(rolDTO.getPermisos());
  rolExistente.getPermisos().clear();
  rolExistente.getPermisos().addAll(nuevosPermisos);
  Rol rolActualizado = rolRepository.save(rolExistente);
  return rolMapper.toRolDTO(rolActualizado);
  public void delete(Long id) {
  if (!rolRepository.existsById(id)) {
  throw new RuntimeException("Rol no encontrado con ID: " + id);
  rolRepository.deleteById(id);
  public Optional<Rol> findByNombreRol(String nombreRol) {
  return rolRepository.findByNombreRol(nombreRol);
}
class PedidoService {
  private String frontendUrl
  BigDecimal totalPedido
  )
  )
  return det
  return dto
  BigDecimal nuevoTotal
  })
  public PedidoDTO create(PedidoDTO pedidoDTO) {
  Pedido pedido = pedidoMapper.toPedido(pedidoDTO);
  pedido.setFechaPedido(LocalDateTime.now());
  pedido.setEstado(EstadoPedido.PENDIENTE);
  pedido.setToken(UUID.randomUUID().toString());
  Proveedor proveedor = proveedorRepository.findById(pedidoDTO.getProveedorId())
  .orElseThrow(() -> new EntityNotFoundException("Proveedor no encontrado"));
  Usuario usuario = usuarioRepository.findById(pedidoDTO.getUsuarioId())
  .orElseThrow(() -> new EntityNotFoundException("Usuario no encontrado"));
  pedido.setProveedor(proveedor);
  pedido.setUsuario(usuario);
  Set<DetallePedido> detalles = new HashSet<>();
  for (DetallePedidoDTO detalleDTO : pedidoDTO.getDetalles()) {
  Producto producto = productoRepository.findById(detalleDTO.getProductoId())
  .orElseThrow(() -> new EntityNotFoundException("Producto no encontrado: " + detalleDTO.getProductoId()));
  DetallePedido detalle = pedidoMapper.toDetallePedido(detalleDTO);
  detalle.setPedido(pedido);
  detalle.setProducto(producto);
  if (detalleDTO.getPrecioUnitario() != null) {
  detalle.setPrecioUnitario(detalleDTO.getPrecioUnitario());
  detalle.setPrecioUnitario(producto.getPrecioCosto());
  detalles.add(detalle);
  totalPedido = totalPedido.add(detalle.getPrecioUnitario().multiply(new BigDecimal(detalle.getCantidad())));
  pedido.setDetalles(detalles);
  pedido.setTotalPedido(totalPedido);
  Pedido pedidoGuardado = pedidoRepository.save(pedido);
  if (proveedor.getEmail() != null && !proveedor.getEmail().isBlank()) {
  logger.info("📧 Generando Orden de Compra #{} para proveedor '{}'...", pedidoGuardado.getId(), proveedor.getRazonSocial());
  byte[] pdfBytes = pdfService.generarOrdenCompraProveedor(pedidoGuardado);
  String linkConfirmacion = frontendUrl + "/proveedor/pedido/" + pedidoGuardado.getToken();
  Context context = new Context();
  context.setVariable("proveedorNombre", proveedor.getRazonSocial());
  context.setVariable("nroPedido", pedidoGuardado.getId());
  context.setVariable("linkConfirmacion", linkConfirmacion);
  String cuerpoHtml = templateEngine.process("email-orden-compra", context);
  String asunto = "Nueva Orden de Compra #" + pedidoGuardado.getId() + " - Masterserv";
  logger.info("✅ Orden de Compra enviada exitosamente a: {}", proveedor.getEmail());
  logger.warn("⚠️ Proveedor '{}' no tiene email registrado. No se envió la notificación.", proveedor.getRazonSocial());
  } catch (Exception e) {
  logger.error("🔴 Error al notificar proveedor: {}", e.getMessage());
  return pedidoMapper.toPedidoDTO(pedidoGuardado);
  public void marcarPedidoCompletado(Long pedidoId, String userEmail) {
  Usuario usuarioQueConfirma = usuarioRepository.findByEmail(userEmail)
  .orElseThrow(() -> new EntityNotFoundException("Usuario '" + userEmail + "' no encontrado."));
  Pedido pedido = pedidoRepository.findById(pedidoId)
  .orElseThrow(() -> new EntityNotFoundException("Pedido no encontrado"));
  if (pedido.getEstado() != EstadoPedido.PENDIENTE && pedido.getEstado() != EstadoPedido.EN_CAMINO) {
  throw new IllegalStateException("Solo se pueden completar pedidos PENDIENTES o EN CAMINO. Estado actual: " + pedido.getEstado());
  for (DetallePedido detalle : pedido.getDetalles()) {
  Long productoId = detalle.getProducto().getId();
  int cantidadRecibida = detalle.getCantidad();
  productoService.reponerStock(productoId, cantidadRecibida);
  movimientoStockService.registrarMovimiento(movDto);
  pedido.setEstado(EstadoPedido.COMPLETADO);
  pedidoRepository.save(pedido);
  public void marcarPedidoCancelado(Long pedidoId) {
  Pedido pedido = pedidoRepository.findById(pedidoId)
  .orElseThrow(() -> new EntityNotFoundException("Pedido no encontrado"));
  if (pedido.getEstado() != EstadoPedido.PENDIENTE) {
  throw new IllegalStateException("Solo se pueden cancelar pedidos PENDIENTES.");
  pedido.setEstado(EstadoPedido.CANCELADO);
  pedidoRepository.save(pedido);
  public PedidoDetalladoDTO obtenerDetallesPedido(Long id) {
  Pedido pedido = pedidoRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Pedido no encontrado: " + id));
  PedidoDetalladoDTO dto = new PedidoDetalladoDTO();
  dto.setId(pedido.getId());
  dto.setFechaPedido(pedido.getFechaPedido());
  dto.setEstado(pedido.getEstado());
  dto.setTotalPedido(pedido.getTotalPedido());
  if (pedido.getProveedor() != null) {
  dto.setProveedorId(pedido.getProveedor().getId());
  dto.setProveedorRazonSocial(pedido.getProveedor().getRazonSocial());
  dto.setProveedorCuit(pedido.getProveedor().getCuit());
  dto.setProveedorEmail(pedido.getProveedor().getEmail());
  if (pedido.getUsuario() != null) {
  dto.setUsuarioSolicitante(pedido.getUsuario().getNombre() + " " + pedido.getUsuario().getApellido());
  List<DetallePedidoDTO> detallesDTO = pedido.getDetalles().stream().map(d -> {
  DetallePedidoDTO det = new DetallePedidoDTO();
  det.setProductoId(d.getProducto().getId());
  det.setProductoNombre(d.getProducto().getNombre());
  det.setProductoCodigo(d.getProducto().getCodigo());
  det.setCantidad(d.getCantidad());
  det.setPrecioUnitario(d.getPrecioUnitario());
  if (d.getPrecioUnitario() != null) {
  det.setSubtotal(d.getPrecioUnitario().multiply(new BigDecimal(d.getCantidad())));
  det.setSubtotal(BigDecimal.ZERO);
  }).collect(Collectors.toList());
  dto.setDetalles(detallesDTO);
  public Page<PedidoDTO> findAll(Pageable pageable) {
  Page<Pedido> pedidoPage = pedidoRepository.findAll(pageable);
  return pedidoPage.map(pedidoMapper::toPedidoDTO);
  public PedidoDTO findById(Long id) {
  Pedido pedido = pedidoRepository.findById(id)
  .orElseThrow(() -> new EntityNotFoundException("Pedido no encontrado: " + id));
  return pedidoMapper.toPedidoDTO(pedido);
  public void confirmarPedidoPorProveedor(String token, ConfirmacionPedidoDTO dto) {
  Pedido pedido = pedidoRepository.findByToken(token)
  .orElseThrow(() -> new EntityNotFoundException("Pedido no encontrado o token inválido."));
  if (pedido.getEstado() != EstadoPedido.PENDIENTE) {
  throw new IllegalStateException("Este pedido ya no está pendiente de confirmación.");
  pedido.setFechaEntregaEstimada(dto.getFechaEntrega());
  if (dto.getItems() != null) {
  for (DetallePedido detalle : pedido.getDetalles()) {
  dto.getItems().stream()
  .filter(item -> item.getProductoId().equals(detalle.getProducto().getId()))
  .findFirst()
  .ifPresent(item -> {
  if (item.getNuevoPrecio() != null && item.getNuevoPrecio().compareTo(BigDecimal.ZERO) >= 0) {
  detalle.setPrecioUnitario(item.getNuevoPrecio());
  nuevoTotal = nuevoTotal.add(detalle.getPrecioUnitario().multiply(new BigDecimal(detalle.getCantidad())));
  pedido.setTotalPedido(nuevoTotal);
  pedido.setEstado(EstadoPedido.EN_CAMINO);
  pedidoRepository.save(pedido);
  logger.info("✅ Pedido #{} confirmado por proveedor. Llega el: {}", pedido.getId(), dto.getFechaEntrega());
  public Page<PedidoDTO> filter(PedidoFiltroDTO filtro, Pageable pageable) {
  var spec = pedidoSpecification.getByFilters(filtro);
  Page<Pedido> pedidosPage = pedidoRepository.findAll(spec, pageable);
  return pedidosPage.map(pedidoMapper::toPedidoDTO);
}
class VentaService {
  Cupon cuponAplicado
  throw ex
  BigDecimal subtotal
  BigDecimal subtotalAplicable
  )
  return BigDecimal.ZERO
  )
  String[] headers
  BigDecimal subtotalSinDescuento
  public VentaDTO create(VentaDTO ventaDTO, String vendedorEmail) {
  Usuario vendedor = usuarioRepository.findByEmail(vendedorEmail)
  .orElseThrow(() -> new RuntimeException("Vendedor no encontrado: " + vendedorEmail));
  Usuario cliente = usuarioRepository.findById(ventaDTO.getClienteId())
  .orElseThrow(() -> new RuntimeException("Cliente no encontrado: " + ventaDTO.getClienteId()));
  Venta venta = new Venta();
  venta.setFechaVenta(LocalDateTime.now());
  venta.setEstado(EstadoVenta.COMPLETADA);
  venta.setVendedor(vendedor);
  venta.setCliente(cliente);
  venta.setDetalles(new HashSet<>());
  venta.setMontoDescuento(null);
  if (ventaDTO.getCodigoCupon() != null && !ventaDTO.getCodigoCupon().isBlank()) {
  cuponAplicado = cuponService.validarCupon(ventaDTO.getCodigoCupon(), cliente);
  venta.setCupon(cuponAplicado);
  } catch (CuponNoValidoException ex) {
  logger.warn("Cupón no válido: {}", ex.getMessage());
  Set<DetalleVenta> detallesVenta = new HashSet<>();
  for (DetalleVentaDTO d : ventaDTO.getDetalles()) {
  Producto p = productoService.descontarStock(d.getProductoId(), d.getCantidad());
  DetalleVenta det = new DetalleVenta();
  det.setProducto(p);
  det.setCantidad(d.getCantidad());
  det.setPrecioUnitario(p.getPrecioVenta());
  det.setVenta(venta);
  detallesVenta.add(det);
  subtotal = subtotal.add(det.getPrecioUnitario().multiply(BigDecimal.valueOf(det.getCantidad())));
  venta.setDetalles(detallesVenta);
  BigDecimal descuentoTotal = calcularDescuento(cuponAplicado, subtotal, detallesVenta);
  venta.setTotalVenta(subtotal.subtract(descuentoTotal).max(BigDecimal.ZERO));
  if (cuponAplicado != null) {
  cuponService.marcarCuponComoUsado(cuponAplicado, venta);
  Venta ventaGuardada = ventaRepository.save(venta);
  for (DetalleVenta det : ventaGuardada.getDetalles()) {
  registrarMovimientoStockSalida(ventaGuardada, det, vendedor);
  puntosService.asignarPuntosPorVenta(ventaGuardada);
  carritoService.vaciarCarrito(vendedorEmail);
  eventPublisher.publishEvent(new VentaRealizadaEvent(this, ventaGuardada.getId()));
  new Thread(() -> {
  Thread.sleep(2000);
  procesoAutomaticoService.generarPrePedidosAgrupados();
  } catch (Exception e) {
  logger.error("Error trigger automático reposición: " + e.getMessage());
  }).start();
  return ventaMapper.toVentaDTO(ventaGuardada);
  private BigDecimal calcularDescuento(Cupon cupon, BigDecimal subtotal, Set<DetalleVenta> detalles) {
  if (cupon == null) return BigDecimal.ZERO;
  if (cupon.getTipoDescuento() == TipoDescuento.FIJO) {
  return cupon.getValor().min(subtotal);
  if (cupon.getTipoDescuento() == TipoDescuento.PORCENTAJE) {
  BigDecimal porcentaje = cupon.getValor().divide(new BigDecimal(100), 4, RoundingMode.HALF_UP);
  if (cupon.getCategoria() != null) {
  Long categoriaIdDescuento = cupon.getCategoria().getId();
  for (DetalleVenta det : detalles) {
  if (det.getProducto().getCategoria().getId().equals(categoriaIdDescuento)) {
  det.getPrecioUnitario().multiply(new BigDecimal(det.getCantidad()))
  return subtotalAplicable.multiply(porcentaje).setScale(2, RoundingMode.HALF_UP);
  return subtotal.multiply(porcentaje).setScale(2, RoundingMode.HALF_UP);
  private void registrarMovimientoStockSalida(Venta venta, DetalleVenta det, Usuario vendedor) {
  MovimientoStockDTO mov = new MovimientoStockDTO();
  mov.setProductoId(det.getProducto().getId());
  mov.setUsuarioId(vendedor.getId());
  mov.setTipoMovimiento(TipoMovimiento.SALIDA_VENTA);
  mov.setCantidad(det.getCantidad());
  mov.setMotivo("Salida por Venta #" + venta.getId());
  mov.setVentaId(venta.getId());
  mov.setMotivo("Venta");
  movimientoStockService.registrarMovimiento(mov);
  public void cancelarVenta(Long id, String emailCancela) {
  Venta venta = ventaRepository.findByIdWithDetails(id)
  .orElseThrow(() -> new RuntimeException("Venta no encontrada: " + id));
  if (venta.getEstado() != EstadoVenta.COMPLETADA)
  throw new RuntimeException("Solo se pueden cancelar ventas COMPLETADAS.");
  Usuario user = usuarioRepository.findByEmail(emailCancela)
  .orElseThrow(() -> new RuntimeException("Usuario no encontrado: " + emailCancela));
  for (DetalleVenta det : venta.getDetalles()) {
  productoService.reponerStock(det.getProducto().getId(), det.getCantidad());
  registrarMovimientoStockReposicion(venta, det, user);
  venta.setEstado(EstadoVenta.CANCELADA);
  puntosService.revertirPuntosPorVenta(venta);
  if (venta.getCupon() != null) {
  Cupon c = venta.getCupon();
  if (c.getFechaVencimiento().isAfter(LocalDate.now())) {
  c.setEstado(EstadoCupon.VIGENTE);
  c.setEstado(EstadoCupon.VENCIDO);
  c.setVenta(null);
  venta.setCupon(null);
  ventaRepository.save(venta);
  private void registrarMovimientoStockReposicion(Venta venta, DetalleVenta det, Usuario user) {
  MovimientoStockDTO mov = new MovimientoStockDTO();
  mov.setProductoId(det.getProducto().getId());
  mov.setUsuarioId(user.getId());
  mov.setTipoMovimiento(TipoMovimiento.DEVOLUCION);
  mov.setCantidad(det.getCantidad());
  mov.setMotivo("Reposición por cancelación Venta #" + venta.getId());
  mov.setVentaId(venta.getId());
  movimientoStockService.registrarMovimiento(mov);
  public VentaDTO findById(Long id) {
  return ventaRepository.findByIdWithDetails(id)
  .map(ventaMapper::toVentaDTO)
  .orElseThrow(() -> new RuntimeException("Venta no encontrada: " + id));
  public Page<VentaDTO> findAll(Pageable pageable) {
  return ventaRepository.findAll(pageable).map(ventaMapper::toVentaDTO);
  public Page<VentaDTO> findByCriteriaForVendedor(VentaFiltroDTO filtro, Pageable pageable, String vendedorEmail) {
  Usuario vendedor = usuarioRepository.findByEmail(vendedorEmail)
  .orElseThrow(() -> new RuntimeException("Vendedor logueado no encontrado: " + vendedorEmail));
  filtro.setVendedorId(vendedor.getId());
  Specification<Venta> spec = ventaSpecification.build(filtro);
  return ventaRepository.findAll(spec, pageable).map(ventaMapper::toVentaDTO);
  public Page<VentaDTO> findByCriteria(VentaFiltroDTO filtro, Pageable pageable) {
  Specification<Venta> spec = ventaSpecification.build(filtro);
  return ventaRepository.findAll(spec, pageable).map(ventaMapper::toVentaDTO);
  public Page<VentaResumenDTO> findVentasByClienteEmail(String email, Pageable pageable) {
  Usuario cliente = usuarioRepository.findByEmail(email)
  .orElseThrow(() -> new RuntimeException("Cliente no encontrado: " + email));
  Pageable ordenado = PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), Sort.by("fechaVenta").descending());
  return ventaRepository.findByCliente(cliente, ordenado).map(ventaMapper::toVentaResumenDTO);
  public Venta findVentaByIdWithDetails(Long id) {
  return ventaRepository.findByIdWithDetails(id)
  .orElseThrow(() -> new RuntimeException("Venta no encontrada: " + id));
  public byte[] generarComprobantePdf(Long ventaId) {
  Venta venta = findVentaByIdWithDetails(ventaId);
  try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
  Document document = new Document(PageSize.A4);
  PdfWriter.getInstance(document, out);
  document.open();
  Font fontTitulo = new Font(Font.HELVETICA, 20, Font.BOLD);
  Paragraph titulo = new Paragraph("MASTERSERV360", fontTitulo);
  titulo.setAlignment(Element.ALIGN_CENTER);
  document.add(titulo);
  Font fontSubtitulo = new Font(Font.HELVETICA, 10, Font.NORMAL, Color.GRAY);
  datosEmpresa.setAlignment(Element.ALIGN_CENTER);
  datosEmpresa.setSpacingAfter(20);
  document.add(datosEmpresa);
  LineSeparator separator = new LineSeparator();
  separator.setLineColor(Color.LIGHT_GRAY);
  document.add(separator);
  Font fontCuerpo = new Font(Font.HELVETICA, 11, Font.NORMAL);
  Paragraph infoVenta = new Paragraph();
  infoVenta.setSpacingBefore(15);
  infoVenta.setSpacingAfter(15);
  infoVenta.add(new Chunk("Nº Venta: " + venta.getId() + "\n", new Font(Font.HELVETICA, 14, Font.BOLD)));
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
  infoVenta.add("Fecha: " + venta.getFechaVenta().format(formatter) + "\n");
  infoVenta.add("Cliente: " + venta.getCliente().getNombre() + " " + venta.getCliente().getApellido() + "\n");
  if(venta.getCliente().getDocumento() != null) {
  infoVenta.add("DNI/CUIT: " + venta.getCliente().getDocumento() + "\n");
  infoVenta.add("Atendido por: " + (venta.getVendedor() != null ? venta.getVendedor().getNombre() : "Sistema") + "\n");
  document.add(infoVenta);
  PdfPTable table = new PdfPTable(4);
  table.setWidthPercentage(100);
  table.setWidths(new float[]{45f, 10f, 20f, 25f});
  table.setSpacingBefore(10f);
  Font fontHeader = new Font(Font.HELVETICA, 10, Font.BOLD, Color.WHITE);
  for (String header : headers) {
  PdfPCell cell = new PdfPCell(new Phrase(header, fontHeader));
  cell.setBackgroundColor(Color.DARK_GRAY);
  cell.setHorizontalAlignment(Element.ALIGN_CENTER);
  cell.setVerticalAlignment(Element.ALIGN_MIDDLE);
  cell.setPadding(6);
  table.addCell(cell);
  Font fontCell = new Font(Font.HELVETICA, 10);
  for (DetalleVenta det : venta.getDetalles()) {
  PdfPCell cellProd = new PdfPCell(new Phrase(det.getProducto().getNombre(), fontCell));
  cellProd.setPadding(5);
  table.addCell(cellProd);
  PdfPCell cellCant = new PdfPCell(new Phrase(String.valueOf(det.getCantidad()), fontCell));
  cellCant.setHorizontalAlignment(Element.ALIGN_CENTER);
  cellCant.setPadding(5);
  table.addCell(cellCant);
  PdfPCell cellPrecio = new PdfPCell(new Phrase("$" + det.getPrecioUnitario(), fontCell));
  cellPrecio.setHorizontalAlignment(Element.ALIGN_RIGHT);
  cellPrecio.setPadding(5);
  table.addCell(cellPrecio);
  BigDecimal subItem = det.getPrecioUnitario().multiply(BigDecimal.valueOf(det.getCantidad()));
  subtotalSinDescuento = subtotalSinDescuento.add(subItem);
  PdfPCell cellSub = new PdfPCell(new Phrase("$" + subItem, fontCell));
  cellSub.setHorizontalAlignment(Element.ALIGN_RIGHT);
  cellSub.setPadding(5);
  table.addCell(cellSub);
  document.add(table);
  Paragraph totales = new Paragraph();
  totales.setAlignment(Element.ALIGN_RIGHT);
  totales.setSpacingBefore(15);
  BigDecimal descuento = subtotalSinDescuento.subtract(venta.getTotalVenta());
  if (descuento.compareTo(BigDecimal.ZERO) > 0) {
  totales.add(new Chunk("Subtotal: $" + subtotalSinDescuento + "\n", new Font(Font.HELVETICA, 10)));
  String cuponTexto = (venta.getCupon() != null) ? " (" + venta.getCupon().getCodigo() + ")" : "";
  totales.add(new Chunk("Descuento aplicado" + cuponTexto + ": -$" + descuento + "\n", new Font(Font.HELVETICA, 10, Font.BOLD, Color.RED)));
  totales.add(new Chunk("TOTAL: $" + venta.getTotalVenta(), new Font(Font.HELVETICA, 18, Font.BOLD)));
  document.add(totales);
  document.close();
  return out.toByteArray();
  } catch (Exception e) {
  logger.error("Error al generar PDF", e);
  throw new RuntimeException("Error al generar comprobante PDF");
}
class CarritoService {
  })
  BigDecimal total
  int cantidadTotalItems
  )
  )
  public CarritoDTO getCarritoByVendedorEmail(String vendedorEmail) {
  Usuario vendedor = usuarioRepository.findByEmail(vendedorEmail)
  .orElseThrow(() -> new RuntimeException("Vendedor no encontrado: " + vendedorEmail));
  Carrito carrito = carritoRepository.findByVendedorWithItemsLock(vendedor)
  .orElseGet(() -> {
  Carrito nuevoCarrito = new Carrito();
  nuevoCarrito.setVendedor(vendedor);
  nuevoCarrito.setItems(new HashSet<>());
  return carritoRepository.save(nuevoCarrito);
  return mapAndCalculateTotals(carrito);
  public CarritoDTO agregarItem(String vendedorEmail, AddItemCarritoDTO itemDTO) {
  Carrito carrito = findCarritoByVendedorEmailOrFail(vendedorEmail);
  Producto producto = productoRepository.findById(itemDTO.getProductoId())
  .orElseThrow(() -> new RuntimeException("Producto no encontrado: ID " + itemDTO.getProductoId()));
  if (producto.getStockActual() < itemDTO.getCantidad()) {
  throw new StockInsuficienteException("Stock insuficiente");
  Optional<ItemCarrito> itemExistenteOpt = itemCarritoRepository.findByCarritoAndProducto(carrito, producto);
  if (itemExistenteOpt.isPresent()) {
  ItemCarrito itemExistente = itemExistenteOpt.get();
  int nuevaCantidad = itemExistente.getCantidad() + itemDTO.getCantidad();
  if (producto.getStockActual() < nuevaCantidad) {
  throw new StockInsuficienteException("Stock insuficiente");
  itemExistente.setCantidad(nuevaCantidad);
  itemCarritoRepository.save(itemExistente);
  ItemCarrito nuevoItem = new ItemCarrito();
  nuevoItem.setCarrito(carrito);
  nuevoItem.setProducto(producto);
  nuevoItem.setCantidad(itemDTO.getCantidad());
  ItemCarrito itemGuardado = itemCarritoRepository.save(nuevoItem);
  if (carrito.getItems() == null) carrito.setItems(new HashSet<>());
  carrito.getItems().add(itemGuardado);
  return mapAndCalculateTotals(carrito);
  public CarritoDTO quitarItem(String vendedorEmail, Long itemCarritoId) {
  Carrito carrito = findCarritoByVendedorEmailOrFail(vendedorEmail);
  ItemCarrito itemParaQuitar = itemCarritoRepository.findById(itemCarritoId)
  .orElseThrow(() -> new RuntimeException("Item no encontrado"));
  if (!itemParaQuitar.getCarrito().getId().equals(carrito.getId())) {
  throw new SecurityException("Acceso denegado al item");
  if (carrito.getItems() != null) carrito.getItems().remove(itemParaQuitar);
  itemCarritoRepository.delete(itemParaQuitar);
  return mapAndCalculateTotals(carrito);
  public CarritoDTO actualizarCantidadItem(String vendedorEmail, Long itemCarritoId, int nuevaCantidad) {
  if (nuevaCantidad <= 0) return quitarItem(vendedorEmail, itemCarritoId);
  Carrito carrito = findCarritoByVendedorEmailOrFail(vendedorEmail);
  ItemCarrito item = itemCarritoRepository.findById(itemCarritoId)
  .orElseThrow(() -> new RuntimeException("Item no encontrado"));
  if (!item.getCarrito().getId().equals(carrito.getId())) throw new SecurityException("Acceso denegado");
  if (item.getProducto().getStockActual() < nuevaCantidad) throw new StockInsuficienteException("Stock insuficiente");
  item.setCantidad(nuevaCantidad);
  itemCarritoRepository.save(item);
  return mapAndCalculateTotals(carrito);
  public CarritoDTO vaciarCarrito(String vendedorEmail) {
  Carrito carrito = findCarritoByVendedorEmailOrFail(vendedorEmail);
  if (carrito.getItems() != null) carrito.getItems().clear();
  carritoRepository.save(carrito);
  return mapAndCalculateTotals(carrito);
  private Carrito findCarritoByVendedorEmailOrFail(String vendedorEmail) {
  Usuario vendedor = usuarioRepository.findByEmail(vendedorEmail)
  .orElseThrow(() -> new RuntimeException("Vendedor no encontrado"));
  return carritoRepository.findByVendedorWithItemsLock(vendedor)
  .orElseThrow(() -> new RuntimeException("Carrito no encontrado"));
  private CarritoDTO mapAndCalculateTotals(Carrito carrito) {
  Set<ItemCarrito> items = carrito.getItems() != null ? carrito.getItems() : new HashSet<>();
  List<ItemCarritoDTO> itemDTOs = new ArrayList<>();
  for (ItemCarrito item : items) {
  BigDecimal sub = item.getProducto().getPrecioVenta().multiply(BigDecimal.valueOf(item.getCantidad()));
  total = total.add(sub);
  cantidadTotalItems += item.getCantidad();
  Long catId = (item.getProducto().getCategoria() != null) ? item.getProducto().getCategoria().getId() : null;
  itemDTOs.add(itemDto);
}
class CuponNoValidoException {
  public CuponNoValidoException(String message) {
  super(message);
}
RuntimeException <|-- CuponNoValidoException
class StockInsuficienteException {
  public StockInsuficienteException(String message) {
  super(message);
}
RuntimeException <|-- StockInsuficienteException
class GlobalExceptionHandler {
  )
  public ResponseEntity<Map<String, String>> handleAuthenticationException(AuthenticationException e) {
  .status(HttpStatus.UNAUTHORIZED)
  .body(Map.of("status", "error", "message", "Credenciales inválidas"));
  public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
  "errors", ex.getBindingResult().getFieldErrors().stream()
  .map(err -> Map.of("field", err.getField(), "defaultMessage", err.getDefaultMessage()))
  .collect(Collectors.toList())
  return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
  public ResponseEntity<Map<String, String>> handleEntityNotFoundException(EntityNotFoundException e) {
  .status(HttpStatus.NOT_FOUND)
  .body(Map.of("status", "error", "message", e.getMessage()));
  public ResponseEntity<Map<String, String>> handleConflictException(IllegalArgumentException e) {
  .status(HttpStatus.CONFLICT)
  .body(Map.of("status", "error", "message", e.getMessage()));
  public ResponseEntity<Map<String, String>> handleBadRequestBusinessExceptions(RuntimeException e) {
  .status(HttpStatus.BAD_REQUEST)
  .body(Map.of("status", "error", "message", e.getMessage()));
  public ResponseEntity<Map<String, String>> handleAllUncaughtException(Exception e, WebRequest request) {
  logger.error("Error no controlado en la solicitud: {}", request.getDescription(false), e);
  .status(HttpStatus.INTERNAL_SERVER_ERROR)
  .body(Map.of("status", "error", "message", "Ocurrió un error interno en el servidor."));
}
enum TipoMovimiento {
}
enum EstadoListaEspera {
}
enum EstadoPedido {
}
enum EstadoVenta {
}
enum TipoComprobante {
}
enum EstadoItemCotizacion {
}
enum TipoUnidad {
  private final String descripcion
  this.descripcion
  return descripcion
  JUEGO("Juego/Kit");
  TipoUnidad(String descripcion) {
  public String getDescripcion() {
}
enum EstadoUsuario {
}
enum TipoDescuento {
}
enum EstadoCotizacion {
}
enum EstadoCupon {
}
enum TipoMovimientoPuntos {
}
interface ProveedorRepository {
  Optional<Proveedor> findByCuit(String cuit);
  Optional<Proveedor> findByRazonSocial(String razonSocial);
  List<Proveedor> findAll();
  List<Proveedor> findByEstado(EstadoUsuario estado);
  Optional<Proveedor> findById(Long id);
}
JpaRepository <|-- ProveedorRepository
interface ReglaPuntosRepository {
  Optional<ReglaPuntos> findByEstadoRegla(@Param("estado") String estadoRegla);
}
JpaRepository <|-- ReglaPuntosRepository
interface CotizacionRepository {
  Optional<Cotizacion> findByToken(String token);
  List<Cotizacion> findByEstado(EstadoCotizacion estado);
  boolean existsByProveedorAndEstado(Proveedor proveedor, EstadoCotizacion estado);
  boolean existsByProveedorAndEstadoIn(Proveedor proveedor, Collection<EstadoCotizacion> estados);
}
JpaRepository <|-- CotizacionRepository
interface RolRepository {
  Optional<Rol> findByNombreRol(String nombreRol);
}
JpaRepository <|-- RolRepository
interface ComprobanteRepository {
  Optional<Comprobante> findByVenta(Venta venta);
  Optional<Comprobante> findByPedido(Pedido pedido);
  Optional<Comprobante> findByNumero(String numero);
}
JpaRepository <|-- ComprobanteRepository
interface MovimientoPuntosRepository {
  Optional<MovimientoPuntos> findByVentaAndTipoMovimiento(Venta venta, TipoMovimientoPuntos tipo);
  boolean existsByVentaAndTipoMovimiento(Venta venta, TipoMovimientoPuntos tipo);
  List<MovimientoPuntos> findByFechaCaducidadPuntosBeforeAndTipoMovimiento(LocalDateTime fecha, TipoMovimientoPuntos tipo);
}
JpaRepository <|-- MovimientoPuntosRepository
interface SolicitudProductoRepository {
  List<SolicitudProducto> findByDescripcionContainingIgnoreCaseAndProcesadoFalse(String descripcion);
}
JpaRepository <|-- SolicitudProductoRepository
interface AuditoriaRepository {
  List<Auditoria> findAllByOrderByFechaDesc();
  Page<Auditoria> findAllByOrderByFechaDesc(Pageable pageable);
}
JpaRepository <|-- AuditoriaRepository
interface TipoDocumentoRepository {
  Optional<TipoDocumento> findByNombreCorto(String nombreCorto);
}
JpaRepository <|-- TipoDocumentoRepository
interface CuentaPuntosRepository {
  Optional<CuentaPuntos> findByCliente(Usuario cliente);
  Optional<CuentaPuntos> findByClienteId(Long clienteId);
  Optional<CuentaPuntos> findByCliente_Email(String clienteEmail);
  boolean existsByClienteId(Long clienteId);
}
JpaRepository <|-- CuentaPuntosRepository
interface PermisoRepository {
  Optional<Permiso> findByNombrePermiso(String nombrePermiso);
}
JpaRepository <|-- PermisoRepository
interface DetalleVentaRepository {
}
JpaRepository <|-- DetalleVentaRepository
interface ItemCotizacionRepository {
  )
}
JpaRepository <|-- ItemCotizacionRepository
interface DetallePedidoRepository {
}
JpaRepository <|-- DetallePedidoRepository
interface CarritoRepository {
  Optional<Carrito> findByVendedor(Usuario vendedor);
  Optional<Carrito> findByVendedor_Id(Long vendedorId);
  Optional<Carrito> findByVendedorWithItems(com.masterserv.productos.entity.Usuario vendedor);
  Optional<Carrito> findByVendedorWithItemsLock(@Param("vendedor") Usuario vendedor);
}
JpaRepository <|-- CarritoRepository
interface NotificacionRepository {
  List<Notificacion> findByUsuarioOrderByFechaEnvioDesc(Usuario usuario);
}
JpaRepository <|-- NotificacionRepository
interface PasswordResetTokenRepository {
  Optional<PasswordResetToken> findByToken(String token);
  void deleteByUsuario(Usuario usuario);
}
JpaRepository <|-- PasswordResetTokenRepository
interface CuponRepository {
  Optional<Cupon> findByCodigo(String codigo);
  List<Cupon> findByCliente(Usuario cliente);
  List<Cupon> findByClienteAndEstado(Usuario cliente, EstadoCupon estado);
  List<Cupon> findByCliente_EmailOrderByFechaVencimientoDesc(String email);
  List<Cupon> findByCliente_IdAndEstadoOrderByFechaVencimientoAsc(Long clienteId, EstadoCupon estado);
}
JpaRepository <|-- CuponRepository
interface InteraccionChatbotRepository {
  List<InteraccionChatbot> findByUsuarioOrderByFechaDesc(Usuario usuario);
}
JpaRepository <|-- InteraccionChatbotRepository
interface CategoriaRepository {
  Optional<Categoria> findByNombre(String nombre);
  List<Categoria> findByEstado(String estado);
}
JpaRepository <|-- CategoriaRepository
interface VentaRepository {
  Page<Venta> findAll(Pageable pageable);
  Page<Venta> findByClienteId(Long clienteId, Pageable pageable);
  Page<Venta> findByVendedorId(Long vendedorId, Pageable pageable);
  Page<Venta> findByFechaVentaBetween(LocalDateTime inicio, LocalDateTime fin, Pageable pageable);
  Optional<Venta> findByIdWithDetails(@Param("id") Long id);
  BigDecimal sumTotalVentasMesActual();
  Page<Venta> findByCliente(Usuario cliente, Pageable pageable);
  "ORDER BY CAST(v.fechaVenta AS LocalDate) ASC")
  "ORDER BY SUM(dv.cantidad) DESC")
  Optional<BigDecimal> findTotalVentasEntreFechas(@Param("inicio") LocalDateTime inicio, @Param("fin") LocalDateTime fin);
  long countVentasEntreFechas(@Param("inicio") LocalDateTime inicio, @Param("fin") LocalDateTime fin);
  List<VentasPorCategoriaDTO> findVentasPorCategoria(@Param("inicio") LocalDateTime inicio, @Param("fin") LocalDateTime fin);
}
JpaRepository <|-- VentaRepository
interface ItemCarritoRepository {
  Optional<ItemCarrito> findByCarritoAndProducto(Carrito carrito, Producto producto);
  void deleteAllByCarritoId(@Param("carritoId") Long carritoId);
}
JpaRepository <|-- ItemCarritoRepository
interface PedidoRepository {
  Optional<Pedido> findByIdWithDetails(@Param("id") Long id);
  Page<Pedido> findAll(Pageable pageable);
  Optional<Pedido> findByToken(String token);
  List<Pedido> findByEstado(EstadoPedido estado);
  List<Pedido> findByEstadoAndFechaEntregaEstimada(EstadoPedido estado, LocalDate fecha);
}
JpaRepository <|-- PedidoRepository
interface UsuarioRepository {
  Optional<Usuario> findByEmail(String email);
  boolean existsByEmail(String email);
  boolean existsByDocumentoAndTipoDocumento_Id(String documento, Long tipoDocumentoId);
  Optional<Usuario> findByTelefono(String telefono);
  Page<Usuario> findAll(Specification<Usuario> spec, Pageable pageable);
  long countClientesActivos();
  Optional<Usuario> findByDocumento(String documento);
  long countActiveAdmins();
  boolean existsByDocumento(String documento);
}
JpaRepository <|-- UsuarioRepository
interface ListaEsperaRepository {
  List<ListaEspera> findByProductoAndEstado(Producto producto, EstadoListaEspera estado);
  boolean existsByUsuarioIdAndProductoIdAndEstado(Long usuarioId, Long productoId, EstadoListaEspera estado);
  boolean existsByUsuarioIdAndEstado(Long usuarioId, EstadoListaEspera estado);
}
JpaRepository <|-- ListaEsperaRepository
interface MovimientoStockRepository {
  List<MovimientoStock> findByProductoOrderByFechaDesc(Producto producto);
}
JpaRepository <|-- MovimientoStockRepository
interface RecompensaRepository {
  List<Recompensa> findByDescripcionContainingIgnoreCase(String descripcion);
}
JpaRepository <|-- RecompensaRepository
interface ProductoRepository {
  )
  Optional<Producto> findByCodigo(String codigo);
  boolean existsByCodigo(String codigo);
  Optional<Producto> findByNombre(String nombre);
  Optional<Producto> findTopByCodigoStartingWithOrderByCodigoDesc(String prefix);
  List<Producto> findActivosByProveedorId(@Param("proveedorId") Long proveedorId);
  long countProductosBajoStock();
  List<Producto> findProductosConStockBajo();
  Optional<Producto> findByIdForUpdate(@Param("id") Long id);
  List<Producto> findByNombreILike(@Param("termino") String termino, Pageable pageable);
  List<Producto> findByNombreContainingIgnoreCase(String nombre);
  unaccent(p.nombre) ILIKE unaccent(concat('%', :termino, '%'))
  unaccent(p.descripcion) ILIKE unaccent(concat('%', :termino, '%'))
  unaccent(p.codigo) ILIKE unaccent(concat('%', :termino, '%'))
  unaccent(p.nombre) ILIKE unaccent(concat('%', :termino, '%'))
  unaccent(p.descripcion) ILIKE unaccent(concat('%', :termino, '%'))
  unaccent(p.codigo) ILIKE unaccent(concat('%', :termino, '%'))
  Page<Producto> buscarFlexible(@Param("termino") String termino, Pageable pageable);
}
JpaRepository <|-- ProductoRepository
class Permiso {
  private Long id
  private String nombrePermiso
  private String descripcion
}
AuditableEntity <|-- Permiso
class InteraccionChatbot {
  private Long id
  private String mensajeUsuario
  private String respuestaBot
  private LocalDateTime fecha
  private Usuario usuario
  private Producto producto
}
AuditableEntity <|-- InteraccionChatbot
class Cupon {
  private Long id
  private String codigo
  private BigDecimal valor
  private TipoDescuento tipoDescuento
  private LocalDate fechaVencimiento
  private EstadoCupon estado
  private Usuario cliente
  private Venta venta
  private Categoria categoria
}
AuditableEntity <|-- Cupon
class Usuario {
  private Long id
  private String nombre
  private String apellido
  private String email
  private String passwordHash
  private String documento
  private String telefono
  private EstadoUsuario estado
  private boolean debeCambiarPassword
  private TipoDocumento tipoDocumento
  private Set<Rol> roles
  inverseJoinColumns = @JoinColumn(name = "rol_id")
}
AuditableEntity <|-- Usuario
class Comprobante {
  private Long id
  private TipoComprobante tipoComprobante
  private String numero
  private LocalDateTime fechaEmision
  private BigDecimal montoTotal
  private Venta venta
  private Pedido pedido
}
AuditableEntity <|-- Comprobante
class MovimientoPuntos {
  private Long id
  private Integer puntos
  private TipoMovimientoPuntos tipoMovimiento
  private LocalDateTime fechaCaducidadPuntos
  private String descripcion
  private CuentaPuntos cuentaPuntos
  private Venta venta
}
AuditableEntity <|-- MovimientoPuntos
class ItemCarrito {
  private Long id
  private int cantidad
  private Carrito carrito
  private Producto producto
}
class Auditoria {
  private Long id
  private String entidad
  private String entidadId
  private String accion
  private String usuario
  private LocalDateTime fecha
  private String detalle
  private String valorAnterior
  private String valorNuevo
}
class Cotizacion {
  private Long id
  private Proveedor proveedor
  private EstadoCotizacion estado
  private String token
  private LocalDate fechaEntregaOfertada
  private BigDecimal precioTotalOfertado
  private boolean esRecomendada
  private Set<ItemCotizacion> items = new HashSet<>();
}
AuditableEntity <|-- Cotizacion
class Rol {
  private Long id
  private String nombreRol
  private String descripcion
  private Set<Permiso> permisos
  inverseJoinColumns = @JoinColumn(name = "permiso_id")
}
AuditableEntity <|-- Rol
class Pedido {
  private Long id
  private LocalDateTime fechaPedido
  private LocalDate fechaEntregaEstimada
  private EstadoPedido estado
  private String token
  private BigDecimal totalPedido
  private Proveedor proveedor
  private Usuario usuario
  private Set<DetallePedido> detalles
  public void prePersist() {
  if (this.token == null || this.token.isEmpty()) {
  this.token = UUID.randomUUID().toString();
  if (this.fechaPedido == null) {
  this.fechaPedido = LocalDateTime.now();
}
AuditableEntity <|-- Pedido
class TipoDocumento {
  private Long id
  private String nombreCorto
  private String nombreLargo
}
class AuditableEntity {
  protected LocalDateTime fechaCreacion
  protected LocalDateTime fechaModificacion
  private String estadoAnterior
  return estadoAnterior
  public void cargarEstadoAnterior() {
  this.estadoAnterior = mapper.writeValueAsString(this);
  } catch (Exception e) {
  this.estadoAnterior = "Error al serializar: " + e.getMessage();
  public String getEstadoAnterior() {
}
class ItemCotizacion {
  private Long id
  private Cotizacion cotizacion
  private Producto producto
  private int cantidadSolicitada
  private EstadoItemCotizacion estado
  private BigDecimal precioUnitarioOfertado
}
AuditableEntity <|-- ItemCotizacion
class PasswordResetToken {
  private Long id
  private String token
  private Usuario usuario
  private LocalDateTime fechaExpiracion
  this.token
  this.usuario
  public PasswordResetToken(String token, Usuario usuario) {
  this.fechaExpiracion = LocalDateTime.now().plusMinutes(60);
  public boolean estaExpirado() {
  return LocalDateTime.now().isAfter(this.fechaExpiracion);
}
class CuentaPuntos {
  private Long id
  private Integer saldoPuntos
  private Usuario cliente
  private java.util.Set<MovimientoPuntos> movimientos
  this.saldoPuntos
  public void prePersist() {
  if (this.saldoPuntos == null) {
}
AuditableEntity <|-- CuentaPuntos
class Proveedor {
  private Long id
  private String razonSocial
  private String cuit
  private String email
  private String telefono
  private String direccion
  private EstadoUsuario estado
  inverseJoinColumns = @JoinColumn(name = "categoria_id")
  private Set<Categoria> categorias = new HashSet<>();
  public boolean equals(Object o) {
  if (this == o) return true;
  if (!(o instanceof Proveedor)) return false;
  Proveedor that = (Proveedor) o;
  return id != null && id.equals(that.id);
  public int hashCode() {
  return getClass().hashCode();
}
AuditableEntity <|-- Proveedor
class Producto {
  private Long id
  private String codigo
  private String nombre
  private String descripcion
  private BigDecimal precioVenta
  private BigDecimal precioCosto
  private String imagenUrl
  private int stockActual
  private int stockMinimo
  private int loteReposicion
  private String estado
  private Categoria categoria
}
AuditableEntity <|-- Producto
class Recompensa {
  private Long id
  private String descripcion
  private int puntosRequeridos
  private Integer stock
  private Boolean activo
  private TipoDescuento tipoDescuento
  private BigDecimal valor
  private Categoria categoria
  public void prePersist() {
  if (this.stock == null) this.stock = 0;
  if (this.activo == null) this.activo = true;
}
class Categoria {
  private Long id
  private String nombre
  private String descripcion
  private String estado
  private Set<Proveedor> proveedores = new HashSet<>();
  public boolean equals(Object o) {
  if (this == o) return true;
  if (!(o instanceof Categoria)) return false;
  Categoria that = (Categoria) o;
  return id != null && id.equals(that.id);
  public int hashCode() {
  return getClass().hashCode();
}
AuditableEntity <|-- Categoria
class MovimientoStock {
  private Long id
  private TipoMovimiento tipoMovimiento
  private int cantidad
  private LocalDateTime fecha
  private String motivo
  private Producto producto
  private Usuario usuario
}
class Venta {
  private Long id
  private LocalDateTime fechaVenta
  private EstadoVenta estado
  private BigDecimal totalVenta
  private Usuario vendedor
  private Usuario cliente
  private Set<DetalleVenta> detalles
  private Cupon cupon
  private BigDecimal montoDescuento
}
AuditableEntity <|-- Venta
class ReglaPuntos {
  private Long id
  private String descripcion
  private BigDecimal montoGasto
  private Integer puntosGanados
  private BigDecimal equivalenciaPuntos
  private String estadoRegla
  private Integer caducidadPuntosMeses
  private LocalDate vigenciaDesde
  private LocalDate vigenciaHasta
  public boolean equals(Object o) {
  if (this == o) return true;
  if (!(o instanceof ReglaPuntos)) return false;
  ReglaPuntos that = (ReglaPuntos) o;
  return id != null && id.equals(that.id);
  public int hashCode() {
  return getClass().hashCode();
}
AuditableEntity <|-- ReglaPuntos
class DetallePedido {
  private Long id
  private int cantidad
  private BigDecimal precioUnitario
  private Pedido pedido
  private Producto producto
  return BigDecimal.ZERO
  public BigDecimal getSubtotal() {
  if (precioUnitario != null) {
  return precioUnitario.multiply(BigDecimal.valueOf(cantidad));
}
class DetalleVenta {
  private Long id
  private int cantidad
  private BigDecimal precioUnitario
  private Venta venta
  private Producto producto
}
class SolicitudProducto {
  private Long id
  private String descripcion
  private LocalDateTime fechaSolicitud
  private boolean procesado
  private Usuario usuario
  this.descripcion
  this.usuario
  this.procesado
  public SolicitudProducto(String descripcion, Usuario usuario) {
  this.fechaSolicitud = LocalDateTime.now();
}
class ListaEspera {
  private Long id
  private LocalDate fechaInscripcion
  private EstadoListaEspera estado
  private Usuario usuario
  private Producto producto
}
class Notificacion {
  private Long id
  private String tipo
  private String mensaje
  private LocalDateTime fechaEnvio
  private String estado
  private Usuario usuario
  private ListaEspera listaEspera
}
class Carrito {
  private Long id
  private Usuario vendedor
  private Set<ItemCarrito> items = new HashSet<>();
}
AuditableEntity <|-- Carrito
class JacksonConfig {
  return objectMapper
  public ObjectMapper objectMapper() {
  ObjectMapper objectMapper = new ObjectMapper();
  Hibernate6Module hibernate6Module = new Hibernate6Module();
  objectMapper.registerModule(hibernate6Module);
  JavaTimeModule javaTimeModule = new JavaTimeModule();
  objectMapper.registerModule(javaTimeModule);
  objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
}
class BeanUtil {
  private static ApplicationContext context
  context
  public void setApplicationContext(ApplicationContext applicationContext) {
  public static <T> T getBean(Class<T> beanClass) {
  return context.getBean(beanClass);
}
ApplicationContextAware <|.. BeanUtil
class SecurityConfig {
  private JwtAuthenticationFilter jwtAuthenticationFilter
  ))
  return source
  public SecurityFilterChain securityFilterChain(HttpSecurity http)
  .ignoringRequestMatchers("/bot/**")
  .disable()
  .cors(cors -> cors.configurationSource(corsConfigurationSource()))
  .requestMatchers("/").permitAll()
  .requestMatchers("/bot/**").permitAll()
  .requestMatchers("/auth/**", "/error", "/health").permitAll()
  .requestMatchers("/auth/forgot-password", "/auth/reset-password").permitAll()
  .requestMatchers(HttpMethod.GET, "/productos/**").permitAll()
  .requestMatchers(HttpMethod.POST, "/productos/filtrar").permitAll()
  .requestMatchers(HttpMethod.GET, "/categorias/**").permitAll()
  .requestMatchers(HttpMethod.GET, "/tipos-documento/**").permitAll()
  .requestMatchers("/public/**").permitAll()
  .anyRequest().authenticated()
  session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
  return http.build();
  public PasswordEncoder passwordEncoder() {
  return new BCryptPasswordEncoder();
  public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration)
  return authenticationConfiguration.getAuthenticationManager();
  public CorsConfigurationSource corsConfigurationSource() {
  CorsConfiguration configuration = new CorsConfiguration();
  configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));
  configuration.setAllowedHeaders(List.of("*"));
  configuration.setAllowCredentials(true);
  UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
  source.registerCorsConfiguration("/**", configuration);
}
interface PermisoMapper {
  PermisoDTO toPermisoDTO(Permiso permiso);
  List<PermisoDTO> toPermisoDTOList(List<Permiso> permisos);
  Permiso toPermiso(PermisoDTO permisoDTO);
}
interface CarritoMapper {
  ItemCarritoDTO toItemCarritoDTO(ItemCarrito item);
  List<ItemCarritoDTO> toItemCarritoDTOList(Set<ItemCarrito> items);
  CarritoDTO toCarritoDTO(Carrito carrito);
  default void afterToItemCarritoDTO(ItemCarrito source, @MappingTarget ItemCarritoDTO target) {
  if (source.getProducto() != null && source.getProducto().getCategoria() != null) {
  target.setProductoCategoriaId(source.getProducto().getCategoria().getId());
}
interface ReglaPuntosMapper {
  ReglaPuntosDTO toReglaPuntosDTO(ReglaPuntos reglaPuntos);
  ReglaPuntos toReglaPuntos(ReglaPuntosDTO reglaPuntosDTO);
  List<ReglaPuntosDTO> toReglaPuntosDTOList(List<ReglaPuntos> reglaPuntosList);
  List<ReglaPuntos> toReglaPuntosList(List<ReglaPuntosDTO> reglaPuntosDTOList);
}
interface RecompensaMapper {
  return regla
  return categoria
  RecompensaDTO toDto(Recompensa recompensa);
  Recompensa toEntity(RecompensaDTO dto);
  default ReglaPuntos idToReglaPuntos(Long id) {
  if (id == null) return null;
  ReglaPuntos regla = new ReglaPuntos();
  regla.setId(id);
  default Categoria idToCategoria(Long id) {
  if (id == null) return null;
  Categoria categoria = new Categoria();
  categoria.setId(id);
  default void afterToDto(Recompensa entity, @MappingTarget RecompensaDTO dto) {
  if (entity.getCategoria() != null) {
  dto.setCategoriaId(entity.getCategoria().getId());
  dto.setCategoriaNombre(entity.getCategoria().getNombre());
}
interface PedidoMapper {
  return p
  return u
  return p
  DetallePedidoDTO toDetallePedidoDTO(DetallePedido detalle);
  PedidoDTO toPedidoDTO(Pedido pedido);
  List<PedidoDTO> toPedidoDTOList(List<Pedido> pedidos);
  Pedido toPedido(PedidoDTO pedidoDTO);
  DetallePedido toDetallePedido(DetallePedidoDTO detalleDTO);
  default Proveedor mapProveedor(Long id) {
  if (id == null) return null;
  Proveedor p = new Proveedor();
  p.setId(id);
  default Usuario mapUsuario(Long id) {
  if (id == null) return null;
  Usuario u = new Usuario();
  u.setId(id);
  default Producto mapProducto(Long id) {
  if (id == null) return null;
  Producto p = new Producto();
  p.setId(id);
}
interface UsuarioMapper {
  return null
  return tipoDocumento
  UsuarioDTO toUsuarioDTO(Usuario usuario);
  List<UsuarioDTO> toUsuarioDTOList(List<Usuario> usuarios);
  Usuario toUsuario(UsuarioDTO usuarioDTO);
  void updateUsuarioFromDto(UsuarioDTO dto, @MappingTarget Usuario entity);
  default TipoDocumento mapTipoDocumento(Long tipoDocumentoId) {
  if (tipoDocumentoId == null) {
  TipoDocumento tipoDocumento = new TipoDocumento();
  tipoDocumento.setId(tipoDocumentoId);
}
interface ClienteMapper {
  return null
  return tipoDocumento
  ClientePerfilDTO toClientePerfilDTO(Usuario usuario);
  void updateUsuarioFromDTO(ClientePerfilUpdateDTO dto, @MappingTarget Usuario usuario);
  default TipoDocumento map(Long tipoDocumentoId) {
  if (tipoDocumentoId == null) {
  TipoDocumento tipoDocumento = new TipoDocumento();
  tipoDocumento.setId(tipoDocumentoId);
}
class VentaMapper {
  BigDecimal subtotalReal
  return u
  public abstract VentaDTO toVentaDTO(Venta venta);
  protected void completarDatos(@MappingTarget VentaDTO dto, Venta venta) {
  if (venta.getCliente() != null) {
  dto.setClienteNombre(venta.getCliente().getNombre() + " " + venta.getCliente().getApellido());
  if (venta.getVendedor() != null) {
  dto.setVendedorId(venta.getVendedor().getId());
  dto.setVendedorNombre(venta.getVendedor().getNombre() + " " + venta.getVendedor().getApellido());
  if (venta.getFechaVenta() != null) {
  dto.setFechaVenta(venta.getFechaVenta());
  if (venta.getDetalles() != null) {
  for (DetalleVenta d : venta.getDetalles()) {
  BigDecimal subItem = d.getPrecioUnitario().multiply(new BigDecimal(d.getCantidad()));
  subtotalReal = subtotalReal.add(subItem);
  if (venta.getTotalVenta() != null) {
  BigDecimal descuento = subtotalReal.subtract(venta.getTotalVenta());
  if (descuento.compareTo(BigDecimal.ZERO) > 0) {
  dto.setMontoDescuento(descuento);
  dto.setMontoDescuento(BigDecimal.ZERO);
  public abstract DetalleVentaDTO toDetalleVentaDTO(DetalleVenta detalle);
  public abstract Venta toVenta(VentaDTO ventaDTO);
  public abstract List<VentaDTO> toVentaDTOList(List<Venta> ventas);
  public abstract VentaResumenDTO toVentaResumenDTO(Venta venta);
  public Usuario mapUsuario(Long id) {
  if (id == null) return null;
  Usuario u = new Usuario();
  u.setId(id);
  public abstract DetalleVenta toDetalleVenta(DetalleVentaDTO dto);
}
interface MovimientoStockMapper {
  return p
  return u
  MovimientoStock toMovimientoStock(MovimientoStockDTO dto);
  default Producto mapProducto(Long id) {
  if (id == null) return null;
  Producto p = new Producto();
  p.setId(id);
  default Usuario mapUsuario(Long id) {
  if (id == null) return null;
  Usuario u = new Usuario();
  u.setId(id);
}
interface RolMapper {
  RolDTO toRolDTO(Rol rol);
  List<RolDTO> toRolDTOList(List<Rol> roles);
  Rol toRol(RolDTO rolDTO);
  void updateRolFromDto(RolDTO dto, @MappingTarget Rol entity);
}
interface ProductoMapper {
  return categoria
  ProductoDTO toProductoDTO(Producto producto);
  List<ProductoDTO> toProductoDTOList(List<Producto> productos);
  Producto toProducto(ProductoDTO productoDTO);
  void updateProductoFromDto(ProductoDTO dto, @MappingTarget Producto entity);
  default Categoria map(Long categoriaId) {
  if (categoriaId == null) return null;
  Categoria categoria = new Categoria();
  categoria.setId(categoriaId);
  ProductoPublicoDTO toProductoPublicoDTO(Producto producto);
}
interface CuponMapper {
  CuponDTO toCuponDTO(Cupon cupon);
  List<CuponDTO> toCuponDTOList(List<Cupon> cupones);
}
interface ProveedorMapper {
  return null
  return null
  return categoria
  ProveedorDTO toProveedorDTO(Proveedor proveedor);
  List<ProveedorDTO> toProveedorDTOList(List<Proveedor> proveedores);
  Proveedor toProveedor(ProveedorDTO proveedorDTO);
  void updateProveedorFromDto(ProveedorDTO dto, @MappingTarget Proveedor entity);
  default Set<Long> categoriasToCategoriaIds(Set<Categoria> categorias) {
  if (categorias == null) {
  return categorias.stream().map(Categoria::getId).collect(Collectors.toSet());
  default Set<Categoria> categoriaIdsToCategorias(Set<Long> categoriaIds) {
  if (categoriaIds == null) {
  return categoriaIds.stream().map(id -> {
  Categoria categoria = new Categoria();
  categoria.setId(id);
  }).collect(Collectors.toSet());
}
interface MovimientoPuntosMapper {
  MovimientoPuntosDTO toDTO(MovimientoPuntos movimientoPuntos);
  MovimientoPuntos toEntity(MovimientoPuntosDTO movimientoPuntosDTO);
}
interface CategoriaMapper {
  CategoriaDTO toCategoriaDTO(Categoria categoria);
  List<CategoriaDTO> toCategoriaDTOList(List<Categoria> categorias);
  Categoria toCategoria(CategoriaDTO categoriaDTO);
  void updateCategoriaFromDto(CategoriaDTO dto, @MappingTarget Categoria entity);
}
@enduml